---
layout: post
title: MySQL锁
date: 2019-06-09
categories:
    - MySQL
comments: true
permalink: mysql-lock.html
---

InnoDB是基于事务，用来锁定的对象是数据库中的对象，如表、页、行。一般锁仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）
可以通过`innodb_trx`,`innodb_locks`, `innodb_lock_waits`来观察锁的信息

**表锁：**操作对象是数据表。Mysql大多数锁策略都支持，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。

**行级锁：**操作对象是数据表中的一行。是MVCC技术用的比较多的。行级锁对系统开销较大，但处理高并发较好。

**注意**InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁，也就是说，InnoDB的行锁是基于索引的

InnoDB提供了下列锁

- 共享/排它锁
- 意向锁
- 记录锁
- 间隙锁
- 临键锁
- 插入意向锁
- 自增锁

# 共享/排他锁
**共享锁：**也叫读锁、S锁（Shared Locks），若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

**排他锁：**又称写锁、X锁(Exclusive Locks)。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

所以我们说S锁和S锁是兼容的，S锁和X锁是不兼容的，X锁和X锁也是不兼容的

## 读操作
对读取的记录加S锁：
```
SELECT ... LOCK IN SHARE MODE;
```
对读取的记录加X锁：
```
SELECT ... FOR UPDATE;
```

## 写操作

**DELETE**

对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取一下这条记录的X锁，然后再执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读。

**UPDATE**

在对一条记录做UPDATE操作时分为三种情况：

1. 如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。
2. 如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT操作提供的隐式锁进行保护。
3. 如果修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE和INSERT的规则进行了。

**INSERT**

一般情况下，新插入一条记录的操作并不加锁，InnoDB通过隐式锁来保护这条新插入的记录在本事务提交前不被别的事务访问，当然在一些特殊情况下INSERT操作也是会获取锁的。


在对某个表执行`SELECT`、`INSERT`、`DELETE`、`UPDATE`语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。

另外，在对某个表执行一些诸如`ALTER TABLE`、`DROP TABLE`这类的DDL语句时，其他事务对这个表并发执行诸如`SELECT`、`INSERT`、`DELETE`、`UPDATE`的语句会发生阻塞，同理，某个事务中对某个表执行`SELECT`、`INSERT`、`DELETE`、`UPDATE`语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁（Metadata Locks，简称MDL）来实现的，一般情况下也不会使用InnoDB存储引擎自己提供的表级别的S锁和X锁。

# 意向锁

InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上的加锁操作，InnoDB提供了意向锁

我们对一个表可以加S锁和X锁。如果一个事务给表加了S锁，别的事务可以继续获得该表的S锁，也可以继续获得该表中的某些记录的S锁，但不能获取该表的X锁和某些记录的X锁；如果一个事务给表加了X锁，别的事务不可以继续获得该表的S锁和X锁，也不可以继续获得该表中的某些记录的S锁和X锁。

如果我们想获取表上的S锁，首先要保证表和表中的记录没有X锁，同样，如果我们想获取表上的X锁，我们要保证表和表中没有S锁或X锁。InnoDB通过意向锁来避免遍历表中的数据判断记录是否存在已经上锁的记录。

**IS锁：**意向共享锁(Intention Shared Lock)，当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁

**IX锁：**意向排他锁(Intention Exclusive Lock)，当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁

IS、IX锁是表级锁，而InnoDB支持的是行级别的锁，因此意向锁是不会阻塞除全表扫描以外的任何请求。所以IS、IX是兼容的。这一块可能会让人理解有点绕。

**IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突**，简单来说，IX,IS是用于事务获取表锁时候判断数据行是否存在锁。它并不会影响行锁

示例

事务 A 先获取了某一行的X锁：
```
SELECT * FROM users WHERE id = 6 FOR UPDATE;
```
事务 B 想要获取表的S锁，检测到A持有IX锁，该请求被阻塞
```
LOCK TABLES users READ;
```
事务 C 也想获取 表中某一行的X锁，意向锁兼容，ID=5不存在锁，所以可以获取到X锁：
```
SELECT * FROM users WHERE id = 5 FOR UPDATE;
```
# 记录锁

# 间隙锁GAP

当我们用范围条件检索数据而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合范围条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。

值得注意的是：间隙锁只会在Repeatable read隔离级别下使用~

例子：假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101

Select * from emp where empid > 100 for update;

上面是一个范围查询，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。

InnoDB使用间隙锁的目的有两个：

    为了防止幻读(上面也说了，Repeatable read隔离级别下再通过GAP锁即可避免了幻读)
    
    满足恢复和复制的需要MySQL的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读

# 临键锁

# 插入意向锁

# 自增锁

# MBL锁

# 死锁

并发的问题就少不了死锁，在MySQL中同样会存在死锁的问题。

但一般来说MySQL通过回滚帮我们解决了不少死锁的问题了，但死锁是无法完全避免的，可以通过以下的经验参考，来尽可能少遇到死锁：

    1）以固定的顺序访问表和行。比如对两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；将两个事务的sql顺序调整为一致，也能避免死锁。
    
    2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
    
    3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
    
    4）降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
    
    5）为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

# 参考资料

https://mp.weixin.qq.com/s/FSyE7Tz5A-Rc1bkC-tDqvA

《MySQL 是怎样运行的：从根儿上理解 MySQL》