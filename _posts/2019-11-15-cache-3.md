---
layout: post
title: 缓存-面临的问题(part3)
date: 2019-11-15
categories:
    - 缓存
comments: true
permalink: cache-3.html
---

# 缓存并发

一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。

解决思路：

对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。但这样会降低系统的吞吐量，需要根据实际情况考虑是否这么做。

**因为字符串也是共享的，我们直接锁缓存key，会阻塞其他使用这个字符串的操作行为，所以我们要加锁的字符串要是一个基于KEY生成的特殊对象.**

```
Object value = cache.get(key);
if (value != null) {
	return value;
}
String lockKey = key + "1190000005886009";
synchronized (lockKey) {
	value = cache.get(key);
	if (value != null) {
		return value;
	}
	value = db.get(key);
	if (value != null) {
		cache.put(key, value)
	}
	return value;
}
```

**在获取到锁之后，我们需要再次从缓存中读取数据，如果有相关数据之间返回**

# 缓存穿透

缓存穿透是指用户查询的数据在数据库一定没有，自然在缓存中也不会有。这样就导致用户查询的时候，每次都要去数据库中查询。在流量大时，可能数据库就挂掉了。

在主从架构，读写分离中，如果写到主库却未同步到从库，就会出现请求穿透到数据库的情况

解决思路：

**1. 存放空值**

如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。

比如我们这个不存在的key预先设定一个特定值"NOT_EXISTS"。在缓存返回这个NOT_EXISTS值的时候，我们的应用就可以认为这是不存在的key，那调用方就可以决定是等待一段事件后重试，还是直接返回不存在。

当然在该KEY对应的数据被插入之后，应该清理缓存，或者将不存在KEY的缓存时间稍微设置短一点。

```
Object value = cache.get(key);
if (value != null) {
	return value;
}
String lockKey = key + "1190000005886009";
synchronized (lockKey) {
	value = cache.get(key);
	if (value != null) {
		return value;
	}
	value = db.get(key);
	if (value == null) {
		value = "NOT_EXISTS"
	}
	cache.put(key, value)
	return value;
}
```

**2.布隆过滤器**

采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的BitSet中，不存在的数据将会被拦截掉，从而避免了对底层存储系统的查询压力。关于布隆过滤器可以在网上搜索相关介绍，它的原理就是利用多个HASH算法将一个对象映射成一个bit数组(也称为bitmap)里面的多个点。以后判断就只要HASH后和数组里面的值亦或下就好了，效率很高。

![](/assets/images/posts/cache/cache-bloom.png)

> BloomFilter的介绍https://edgar615.github.io/bloom-filter.html

针对于一些恶意攻击，攻击带过来的大量key 是不存在的，那么我们采用第一种方案就会缓存大量不存在key的数据，过多的占用缓存空间。此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些key。

针对这种key异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。

当缓存空间满了，同步失败，网络阻塞，缓存写失败等原因，会出现缓存服务器上并没有这个key。或者因为同步中断，在主从架构中，写到主却未同步到从的悲剧，就会出现请求穿透到DB层的情况。

当发生大量的缓存穿透，例如对某个失效的缓存的大并发访问就造成了缓存雪崩。

# 缓存雪崩

缓存雪崩是由于在缓存失效(缓存服务器重启或者大量缓存集中在某一个时间段失效)，新缓存还未到的中间时间内，所有请求都会去查询数据库，而对数据库造成巨大压力甚至宕机。上面提到的缓存并发，缓存穿透都可能会导致缓存雪崩现象发生。

解决思路：

1. 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。这种办法虽然能缓解数据库的压力，但是同时又降低了系统的吞吐量。和缓存并发是同一种处理方式。
2. 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。避免缓存雪崩的出现。
3. 二级缓存，A1为原始缓存，A2为拷贝缓存，A1缓存失效时间设置为短期，A2设置为长期，当A1失效的时候，利用同步（或者其他手段）让一个线程去查询并更新缓存，其他线程直接返回A2的数据。
4. 使用分布式缓存。设计合理的缓存分布算法，让缓存均匀地分布到各个节点，这样一台缓存服务器挂了只是有部分缓存丢失，不会所有压力集中到数据库

上面的思路是从缓存的角度考虑，也可以从设计方面考虑

- **熔断机制：**某个缓存节点不能工作的时候，需要通知缓存代理不要把请求路由到该节点，减少用户等待和请求时长。
- **限流机制：**在接入层和代理层可以做限流，当缓存服务无法支持高并发的时候，前端可以把无法响应的请求放入到队列或者丢弃。
- **隔离机制：**缓存无法提供服务或者正在预热重建的时候，把该请求放入队列中，这样该请求因为被隔离就不会被路由到其他的缓存节点。如此就不会因为这个节点的问题影响到其他节点。当缓存重建以后，再从队列中取出请求依次处理。

## 加锁排队的优化
加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的，同样会导致用户等待超时。对于这个问题对应的解决思路是：

**给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。**

```
Object value = cache.get(key);
//获取标记值
String cacheSign = key + "_Sign";
Object sign = cache.get(cacheSign)
if (sign == null) {
	//过期，用一个线程在后台更新缓存
	new Runnable() {
		Object v = db.get(key);
		cache.put(key, v, cacheTime * 2);
		cache.put(cacheSign, cacheSign, cacheTime);
	}.start()
}
return value;//会出现脏数据
```

- 缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存。
- 缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。

# 缓存预热

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样避免在用户请求的时候，再去加载相关的数据。因为有些系统一旦启动就要面临上千上万的请求进来，如果直接让这些请求打到数据库上，非常大的可能是数据库压力暴增，直接无法正常响应。

为了缓解这个问题，就需要通过“预读取”来解决。

![](/assets/images/posts/cache/cache-prepare.png)


在单机系统情况下比较简单：

1. 直接写个缓存刷新页面，上线时手工操作下
2. 数据量不大，可以在WEB系统启动的时候加载
3. 搞个定时器定时刷新缓存，或者由用户触发都行

分布式缓存系统，如Memcached，Redis，比如缓存系统比较大，由十几台甚至几十台机器组成，这样预热会复杂一些：

解决思路：

1. 写个程序去跑
2. 单个缓存预热框架

# 缓存降级

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。

降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。

在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

- 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
- 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
- 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
- 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

# 参考资料

