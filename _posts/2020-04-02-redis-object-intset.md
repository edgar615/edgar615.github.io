---
layout: post
title: redis数据结构（5）- 整数集合
date: 2020-04-02
categories:
    - redis
comments: true
permalink: redis-object-intset.html
---

>  Redis有六种基础数据结构：动态字符串，链表，字典，跳跃表，整数集合和压缩列表。

# 1. 整数集合

整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t、int64_t的整数值，并且保证集合中不会出现重复元素。

整数集合是集合（Set）的底层实现之一，如果一个集合只包含整数值元素，且元素数量不多时，会使用整数集合作为底层实现

整数集合的定义为`inset.h/inset`

```c
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;

```

- `contents`数组：整数集合的每个元素在数组中按值的大小从小到大排序，且不包含重复项
- `length`记录整数集合的元素数量，即contents数组长度
- `encoding`决定contents数组的真正类型，如INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64
  - 如果 `encoding` 属性的值为 `INTSET_ENC_INT16` ， 那么 `contents` 就是一个 `int16_t` 类型的数组， 数组里的每个项都是一个 `int16_t` 类型的整数值 （最小值为 `-32,768` ，最大值为 `32,767` ）。
  - 如果 `encoding` 属性的值为 `INTSET_ENC_INT32` ， 那么 `contents` 就是一个 `int32_t` 类型的数组， 数组里的每个项都是一个 `int32_t` 类型的整数值 （最小值为 `-2,147,483,648` ，最大值为 `2,147,483,647` ）。
  - 如果 `encoding` 属性的值为 `INTSET_ENC_INT64` ， 那么 `contents` 就是一个 `int64_t` 类型的数组， 数组里的每个项都是一个 `int64_t` 类型的整数值 （最小值为 `-9,223,372,036,854,775,808` ，最大值为 `9,223,372,036,854,775,807` ）。

下图展示了一个整数集合示例：

- `encoding` 属性的值为 `INTSET_ENC_INT16` ， 表示整数集合的底层实现为 `int16_t` 类型的数组， 而集合保存的都是 `int16_t` 类型的整数值。
- `length` 属性的值为 `5` ， 表示整数集合包含五个元素。
- `contents` 数组按从小到大的顺序保存着集合中的五个元素。
- 因为每个集合元素都是 `int16_t` 类型的整数值， 所以 `contents` 数组的大小等于 `sizeof(int16_t) * 5 = 16 * 5 = 80` 位。

![](/assets/images/posts/redis-object/redis-object-12.png)

下图展示了另一个整数集合示例：

- `encoding` 属性的值为 `INTSET_ENC_INT64` ， 表示整数集合的底层实现为 `int64_t` 类型的数组， 而数组中保存的都是 `int64_t` 类型的整数值。
- `length` 属性的值为 `4` ， 表示整数集合包含四个元素。
- `contents` 数组按从小到大的顺序保存着集合中的四个元素。
- 因为每个集合元素都是 `int64_t` 类型的整数值， 所以 `contents` 数组的大小为 `sizeof(int64_t) * 4 = 64 * 4 = 256` 位。

![](/assets/images/posts/redis-object/redis-object-48.png)

虽然 `contents` 数组保存的四个整数值中， 只有 `-2675256175807981027` 是真正需要用 `int64_t` 类型来保存的， 而其他的 `1` 、 `3` 、 `5` 三个值都可以用 `int16_t` 类型来保存， 不过根据整数集合的升级规则， 当向一个底层为 `int16_t` 数组的整数集合添加一个 `int64_t` 类型的整数值时， 整数集合已有的所有元素都会被转换成 `int64_t` 类型， 所以 `contents` 数组保存的四个整数值都是 `int64_t` 类型的， 不仅仅是 `-2675256175807981027` 。

# 2. **整数集合的升级**

每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。

每次向整数集合中添加新元素都有可能会引起升级，每次升级都需要对底层数组已有的所有元素进行类型转换

升级整数集合并添加新元素共分为三步进行：

1. 根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。
2. 将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。
3. 将新元素添加到底层数组里面。

假设现在有一个 `INTSET_ENC_INT16` 编码的整数集合， 集合中包含三个 `int16_t` 类型的元素

![](/assets/images/posts/redis-object/redis-object-13.png)

因为每个元素都占用 `16` 位空间， 所以整数集合底层数组的大小为 `3 * 16 = 48` 位， 下图图展示了整数集合的三个元素在这 `48` 位里的位置。

![](/assets/images/posts/redis-object/redis-object-49.png)

现在， 假设我们要将类型为 `int32_t` 的整数值 `65535` 添加到整数集合里面， 因为 `65535` 的类型 `int32_t` 比整数集合当前所有元素的类型都要长， 所以在将 `65535` 添加到整数集合之前， 程序需要先对整数集合进行升级。

升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。

整数集合目前有三个元素， 再加上新元素 `65535` ， 整数集合需要分配四个元素的空间， 因为每个 `int32_t` 整数值需要占用 `32` 位空间， 所以在空间重分配之后， 底层数组的大小将是 `32 * 4 = 128` 位

![](/assets/images/posts/redis-object/redis-object-14.png)

虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 `1` 、 `2` 、 `3` 仍然是 `int16_t` 类型， 这些元素还保存在数组的前 `48` 位里面， 所以程序接下来要做的就是将这三个元素转换成 `int32_t` 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。

首先， 因为元素 `3` 在 `1` 、 `2` 、 `3` 、 `65535` 四个元素中排名第三， 所以它将被移动到 `contents` 数组的索引 `2` 位置上， 也即是数组 `64` 位至 `95` 位的空间内，

![](/assets/images/posts/redis-object/redis-object-15.png)

接着， 因为元素 `2` 在 `1` 、 `2` 、 `3` 、 `65535` 四个元素中排名第二， 所以它将被移动到 `contents` 数组的索引 `1` 位置上， 也即是数组的 `32` 位至 `63` 位的空间内，

![](/assets/images/posts/redis-object/redis-object-16.png)

之后， 因为元素 `1` 在 `1` 、 `2` 、 `3` 、 `65535` 四个元素中排名第一， 所以它将被移动到 `contents` 数组的索引 `0` 位置上， 也即是数组的 `0` 位至 `31` 位的空间内，

![](/assets/images/posts/redis-object/redis-object-50.png)

后， 因为元素 `65535` 在 `1` 、 `2` 、 `3` 、 `65535` 四个元素中排名第四， 所以它将被添加到 `contents` 数组的索引 `3` 位置上， 也即是数组的 `96` 位至 `127` 位的空间内

![](/assets/images/posts/redis-object/redis-object-51.png)

最后， 程序将整数集合 `encoding` 属性的值从 `INTSET_ENC_INT16` 改为 `INTSET_ENC_INT32` ， 并将 `length` 属性的值从 `3` 改为 `4` ， 设置完成之后的整数集合如下图所示。

![](/assets/images/posts/redis-object/redis-object-52.png)

因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。

其他类型的升级操作， 比如从 `INTSET_ENC_INT16` 编码升级为 `INTSET_ENC_INT64` 编码， 或者从 `INTSET_ENC_INT32` 编码升级为 `INTSET_ENC_INT64` 编码， 升级的过程都和上面展示的升级过程类似。

**升级之后新元素的摆放位置**

因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：

- 在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 `0` ）；
- 在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 `length-1` ）。

整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。

- **提升灵活性**

因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。

比如说， 我们一般只使用 `int16_t` 类型的数组来保存 `int16_t` 类型的值， 只使用 `int32_t` 类型的数组来保存 `int32_t` 类型的值， 诸如此类。

但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 `int16_t` 、 `int32_t` 或者 `int64_t` 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。

- **节约内存**

当然， 要让一个数组可以同时保存 `int16_t` 、 `int32_t` 、 `int64_t` 三种类型的值， 最简单的做法就是直接使用 `int64_t` 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 `int16_t` 类型或者 `int32_t` 类型的值， 数组都需要使用 `int64_t` 类型的空间去保存它们， 从而出现浪费内存的情况。

而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。

比如说， 如果我们一直只向整数集合添加 `int16_t` 类型的值， 那么整数集合的底层实现就会一直是 `int16_t` 类型的数组， 只有在我们要将 `int32_t` 类型或者 `int64_t` 类型的值添加到集合时， 程序才会对数组进行升级。

**整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。**

# 3. 参考资料

http://redisbook.com/preview/intset/datastruct.html

http://redisbook.com/preview/intset/upgrade.html

http://redisbook.com/preview/intset/why_upgrade.html