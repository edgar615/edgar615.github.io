---
layout: post
title: RPC负载均衡
date: 2020-05-17
categories:
    - rpc
comments: true
permalink: rpc-loadbalance.html
---

我们知道负载均衡可以分为服务端负载均衡和客户端负载均衡，而服务端负载均衡又按照实现方式的不同可以划分为软件负载均衡和硬件负载均衡，nginx 便是典型的软件负载均衡。

RPC的负载均衡一般不会采用硬件负载均衡或者基于四层代理软件负载均衡，原因如下

- 搭建负载均衡设备或 TCP/IP 四层代理，需要额外成本
- 请求流量都经过负载均衡设备，多经过一次网络传输，会额外浪费一些性能
- 负载均衡添加节点和摘除节点，一般都要手动添加，当大批量扩容和下线时，会有大量的人工操作，“服务发现”在操作上是个问题
- 我们在服务治理的时候，针对不同接口服务、服务的不同分组，我们的负载均衡策略是需要可配的，如果大家都经过这一个负载均衡设备，就不容易根据不同的场景来配置不同的负载均衡策略了。

# 1. 负载均衡的方法

## 1.1. 代理模型
客户端并不知道服务端的存在，它所有的请求都打到代理服务，由代理服务去分发到服务端，并且实现公平的负载算法。 客户机可能不可信，这种情况通过用户面向用户的服务，类似于我们的nginx将请求分发到后端机器。

![](/assets/images/posts/rpg-loadbalance/rpc-loadbalance-1.png)

![](/assets/images/posts/rpg-loadbalance/rpc-loadbalance-2.png)

缺点： 客户端不知道后端的存在，且客户端不可信，此模型还好增加RPC的延迟，而且代理服务会影响服务本身的吞吐量

优点： 客户端不需要过多的改造，在中间层做监控等拦截操作非常容易。

## 1.2. 客户端负载均衡方式(进程内LB（Balancing-aware Client）)
客户端知道有多个后端服务，由客户端去选择服务端，并且客户端可以从后端服务器中自己总结出一份负载的信息，实现负载均衡算法。例如，客户端可以包含许多用于从列表中选择服务器的负载均衡策略（循环，随机等）。在此模型中，服务器列表将在客户端中静态配置，由名称解析系统提供，外部负载均衡器等。在任何情况下，客户端都负责从列表中选择首选服务器。

![](/assets/images/posts/rpg-loadbalance/rpc-loadbalance-3.png)

优点：高性能，因为消除了第三方的交互

缺点：会使客户端的代码大大复杂化：客户端需要跟踪服务器负载和健康情况，维护负载均衡策略，这些策略可能相当复杂。有些时候我们还需要以多种语言实现和维护负载均衡策略，而且客户端需要被信任得是靠谱的客户端。

# 2. 代理模式的实现方式

代理负载均衡可以是 L3/L4(传输级别) 或 L7(应用程序级别)。

在 L3/L4 中，服务器终止TCP连接并打开另一个连接到所选的后端。

L7 只是在客户端连接到服务端端连接之间搞一个应用来做中间人。

L3/L4 级别的负载均衡按设计只做很少的处理，与L7级别的负载均衡相比的延迟会更少，而且更便宜，因为它消耗更少的资源。

在L7(应用程序级)负载平衡中，负载均衡服务终止并解析协议。负载均衡服务可以检查每个请求并根据请求内容分配后端。这就意味监控拦截等操作可以非常方便快捷的做在这里。

**L3/L4 vs L7**

1. 这些连接之间的RPC负载变化很大： 建议使用L7.
2. 存储或计算相关性很重要 ：建议使用L7，并使用cookie或类似的路由请求来纠正服务端.
3. 设备资源少（缺钱）： 建议使用 L3/L4.
4. 对延迟要求很严格（就是要快）： L3/L4.



# 参考资料

https://www.jianshu.com/p/dd89ef1a645e

https://grpc.io/blog/grpc-load-balancing/

https://www.codercto.com/a/26074.html
