---
layout: post
title: 消息队列
date: 2020-04-16
categories:
    - 架构设计
comments: true
permalink: mq.html
---

# 消息队列特性

- 业务无关，只做消息分发。
- FIFO，先投递先到达。
- 容灾：节点动态增删和消息持久化。
- 性能：吞吐量提升，系统内部通信效率提高。

#  消息队列的作用

异步、解耦、削峰填谷

## 异步
假设这样一个场景，用户下单成功需要给用户发短信，如果没有消息队列，我们会选择同步调用发短信的接口并等待短信发送成功。

![](/assets/images/posts/mq/mq-1.png)

我们忽略中间的网络通信时间消耗，假如订单系统处理需要 150ms，短信系统处理需要 200ms，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。

假如再加一个发送邮件，这样整个系统的调用链又变长了，整个时间就变成了550ms。

![](/assets/images/posts/mq/mq-2.png)

如果使用 MQ，那么订单系统连续发送一条消息到消息队列中，假如耗时 5ms，短息系统和邮件系统从消息队列中异步读取消息，那么对于用户来说，用户的响应时间就变成了155ms

![](/assets/images/posts/mq/mq-3.png)

## 解耦

依然以上面的用户下单的例子为例，最初的伪代码如下

```
void order() {
    // 创建订单
    createOrder();
    // RPC发送短信
    sendSms();
}
```

那么我们又添加了一个发送邮件，就得重新去修改代码

```
void order() {
    // 创建订单
    createOrder();
    // RPC发送短信
    sendSms();
    // RPC发送邮件
    sendMail();
}
```

如果在后面再增加增加积分、送券等业务呢？

```
void order() {
    // 创建订单
    createOrder();
    // RPC发送短信
    sendSms();
    // RPC发送邮件
    sendMail();
    // RPC增加积分 
    addPoints();
    // RPC增加券
    addCoupons();
}
```

一个大规模系统，往往会拆分为几十个甚至上百个子系统，每个子系统又对应N多个服务，这些系统与系统之间有着错综复杂的关系网络。如果某个系统产出一份核心数据，可能下游无数的其他系统都需要这份数据来实现各种业务逻辑。

此时如果你要是采取上面那种模式来设计订单系统，负责订单系统的人估计会被烦死。那么此时我们就可以用一个消息队列在中间进行解耦。订单系统只需要发送一个下单成功的消息到消息队列，下游哪个系统感兴趣自己去消费即可

![](/assets/images/posts/mq/mq-4.png)

## 削峰填谷

上下游对于事情的处理能力是不同的，例如Web前端通过LVS和nginx每秒可以承受上千万的请求。但数据库的处理能力却十分有限，即使使用SSD加分库分表，单机的处理能力仍然在万级，我们不能奢求数据库的机器数量追上前端。

这种问题同样存在于系统和系统之间，如短信系统的速度可能卡在第三方短信平台（每秒几百次请求）。因为订单系统是我们的核心业务，所以它的配置可能会好一些，假设订单系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而短信系统并不是我们的主要业务，所以我们配备的硬件资源并不会太高，在加上第三方短信平台的限制，所有短信平台可能并不能承受一万次请求。

因为短信业务又不是我们的主业务，而且用户晚上个半分钟左右收到短信，一般是不会有太大问题的。我们可以把下单完成的信息发送到消息队列中，而短信系统尽自己所能地去消息队列中取消息和消费消息，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。

这样的结果可能就是在高峰期消息队列中挤压了大量的消息，但等高峰期过了之后，短信系统就会快速将积压的消息给解决掉，这就是填谷

# 消息队列的优缺点
## 系统可用性降低
加入消息队列后，就会增加了一个风险因素：如果消息队列挂了，系统的运行就不对了，可用性降低

## 系统复杂性增加
加入消息队列后，需要考虑消息重复消费、消息丢失、甚至消息顺序性的问题。

为了解决这些问题，又需要引入很多复杂的机制，这样一来是不是系统的复杂度提高了。

## 数据一致性问题
A 系统发送完消息后直接返回成功了，此时C系统读取消息写数据库的时候失败了，就会产生数据不一致问题

# 如何保证消息不被重复消费
其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同。

因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。

解决方案：在收到消息后先将消息持久化到本地数据库，通过数据库的唯一性校验避免出现重复消费的情况

# 死信队列
一般生产环境中，都会在使用MQ的时候设计两个队列：一个是核心业务队列，一个是死信队列。

核心业务队列，就是比如上面专门用来让订单系统发送订单消息的，然后另外一个死信队列就是用来处理异常情况的。

比如说要是第三方物流系统故障了，此时无法请求，那么仓储系统每次消费到一条订单消息，尝试通知发货和配送，都会遇到对方的接口报错。此时仓储系统就可以把这条消息拒绝访问，或者标志位处理失败！注意，这个步骤很重要。

一旦标志这条消息处理失败了之后，MQ就会把这条消息转入提前设置好的一个死信队列中。在第三方物流系统故障期间，所有订单消息全部处理失败，全部会转入死信队列。

然后仓储系统开启一个后台线程，监控第三方物流系统是否正常，能否请求的，不停的监视。一旦发现对方恢复正常，这个后台线程就从死信队列消费出来处理失败的订单，重新执行发货和配送的通知逻辑。

死信队列的使用，其实就是MQ在生产实践中非常重要的一环，也就是架构设计必须要考虑的。