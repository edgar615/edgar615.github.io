---
layout: post
title: 红黑树
date: 2019-06-13
categories:
    - 算法
comments: true
permalink: red-black-tree.html
---

红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

1. 每个节点要么是红的，要么是黑的。  
2. 根节点是黑的。  
3. 每个叶节点（叶节点即指树尾端NIL指针或NULL节点）是黑的。  
4. 如果一个节点是红的，那么它的俩个儿子都是黑的。  
5. 对于任一节点而言，其到叶节点树尾端NIL指针的每一条路径都包含相同数目的黑节点。  

正是红黑树的这5条性质，使得一棵n个节点是红黑树始终保持了logn的高度，从而也就解释了上面我们所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n) 

![](/assets/images/posts/red-black-tree/red-black-tree-1.png)

"叶子节点" 或"NULL节点"，它不包含数据而只充当树在此结束的指示

**黑深度** ——从某个结点x出发(不包括结点x本身)到叶结点(包括叶子结点)的路径上的黑结点个数,称为该结点x的黑深度,记为bd(x),根结点的黑深度就是该红黑树的黑深度。叶子结点的黑深度为0。比如：上图bd(13)=2，bd(8)=2，bd(1)=1 

因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同。然而，在红黑树上进行插入操作和删除操作会导致不 再符合红黑树的性质。恢复红黑树的属性需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。  虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次 。 

红黑树能够以O(log2(N))的时间复杂度进行搜索、插入、删除操作。此外,任何不平衡都会在3次旋转之内解决。这一点是AVL所不具备的。 

**新插入的节点颜色总是红色的**，这是因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小，原因是插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3（因为父节点是黑色的没事，父节点是红色的就违背规则3）。另外违背规则3比违背规则4要更容易修正。当插入一个新的节点时，可能会破坏这种平衡性，

**红-黑树通过变色和选中（左旋、右旋）对树进行修正**

# 插入 
插入需要考虑几种不同的情况

- 父为黑，直接插入
- 父为红，叔叔为红，依次变色
- 父为红，叔叔为黑
	- 左左插入，绕父节点右旋
	- 左右插入，绕自己先左旋，再右旋
	- 右左插入，绕自己先右旋，在左旋
	- 右右插入，绕父节点左旋

这里的旋转在[二叉树](https://edgar615.github.io/mysql-index-2.html)中做了介绍，不再重复，下面看一个完整的例子
## 插入14
插入14，父节点15的颜色是黑色节点，没有破坏结构，不需要做任何改变

![](/assets/images/posts/red-black-tree/red-black-tree-2.png)

由于黑节点个数至少为红节点的两倍，因此父为黑的情况较多，而这种情况在插入后无需任何调整，这就是红黑树比AVL树插入效率高的原因！

## 插入21
插入21，父节点22也是红色的，破坏了规则4`如果一个节点是红的，那么它的俩个儿子都是黑的。`需要做出调整

![](/assets/images/posts/red-black-tree/red-black-tree-3.png)

**1. 变色**
把节点22变黑，但仍然不符合规则5`对于任一节点而言，其到叶节点树尾端NIL指针的每一条路径都包含相同数目的黑节点。`需要将节点25变红，节点27变黑

![](/assets/images/posts/red-black-tree/red-black-tree-4.png)

这时候节点25也不符合规则4`如果一个节点是红的，那么它的俩个儿子都是黑的。`仍然需要调整，这是如果我们继续把节点17变黑，又会破坏规则4，而且也不能继续将节点13变色，因为会破坏规则2`根节点是黑的`，这时就需要通过旋转来解决

**2. 左旋**
上图中右子树中17（不平衡点）变为黑色以后需要把13变成红色，因此进行一次左旋，将17放在根节点，这样既可保证13为红色

![](/assets/images/posts/red-black-tree/red-black-tree-5.png)

**3. 再次变色**
左旋后破坏了规则2，需要对根节点变色，然后同步将子节点变色

![](/assets/images/posts/red-black-tree/red-black-tree-6.png)

变色后发现又不满足规则5`对于任一节点而言，其到叶节点树尾端NIL指针的每一条路径都包含相同数目的黑节点`

**3. 右旋**
找到不平衡的节点，这里是节点13，右旋

![](/assets/images/posts/red-black-tree/red-black-tree-7.png)

右旋完成后发现再次破坏了规则4，继续变色

**4. 再次变色**

再次变色，完成插入

![](/assets/images/posts/red-black-tree/red-black-tree-8.png)


java中的TreeMap以及JDK1.8以后的HashMap在当个节点中链表长度大于8时都会用到。

# 参考资料

https://segmentfault.com/a/1190000012728513

https://cloud.tencent.com/developer/article/1399867

https://blog.csdn.net/qq_34173549/article/details/79636764

https://www.cnblogs.com/ysocean/p/8004211.html
