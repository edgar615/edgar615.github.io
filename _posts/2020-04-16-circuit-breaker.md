---
layout: post
title: 熔断降级
date: 2020-04-12
categories:
    - 分布式
comments: true
permalink: circuit-breaker.html
---

今天稍微复杂点的互联网应用，服务端基本都是分布式的，大量的服务支撑起整个系统，服务之间也难免有大量的依赖关系，依赖都是通过网络连接起来。

![](/assets/images/posts/circuit-breaker/circuit-breaker-1.png)

然而任何一个服务的可用性都不是 100% 的，网络亦是脆弱的。当我依赖的某个服务不可用的时候，我自身是否会被拖死？当网络不稳定的时候，我自身是否会被拖死？这些在单机环境下不太需要考虑的问题，在分布式环境下就不得不考虑了。假设我有5个依赖的服务，他们的可用性都是99.95%，即一年不可用时间约为4个多小时，那么是否意味着我的可用性最多就是 99.95% 的5次方，99.75%（近乎一天），再加上网络不稳定因素、依赖服务可能更多，可用性会更低。

**示例**

分布式系统，随着业务复杂度提高，系统不断拆分，一个面向 C 端的 API 调用，其内部的 RPC 调用层层嵌套，调用链变长，会造成下述 2 个问题：

1. API 接口可用性降低：     
   - 假设一次 api 请求，内部涉及 30 次 rpc 调用
   - 每个微服务可用性 99.99%
   - 则，api 请求的可用性为 99.99% 的 30 次方 = 99.7% ，即，0.3% 的失败率
2. 系统阻塞，拒绝请求接入：     
   - 假设一次 api 请求，内部涉及 10 次 rpc 调用
   - 只要 10 次 rpc 中，有一次请求超时，则，整个 api 调用就超时了
   - 如果大量请求突发访问，则，大量的线程都阻塞（block 等待超时）在这一服务上，新的请求无法接入

为了解决上述「**API 接口可用性降低**」和「**系统阻塞、拒绝请求接入**」问题，可以采用下述 4 中方法：

1. **熔断**：服务熔断，一旦触发「异常统计条件」，则，直接熔断服务，在「调用方」直接返回，不再 rpc 调用远端服务；
2. **降级**：降级是配合「熔断」的，熔断后，不再调用远端服务器的 rpc 接口，而采用本地的 fallback 机制，返回一个「备用方案」/「默认取值」；
3. **限流**：限制「速率」，或从业务层限制「总数」，被限流的请求，直接进入「降级」fallback 流程；
4. **异步 RPC**：通过异步访问，提升系统访问性能；

# 超时
通过网络调用外部依赖服务的时候，都必须应该设置超时。在健康的情况下，一般局域往的一次远程调用在几十毫秒内就返回了，但是当网络拥堵的时候，或者所依赖服务不可用的时候，这个时间可能是好多秒，或者压根就僵死了。通常情况下，一次远程调用对应了一个线程或者进程，如果响应太慢，或者僵死了，那一个进程/线程，就被拖死，短时间内得不到释放，而进程/线程都对应了系统资源，这就等于说我自身服务资源会被耗尽，导致自身服务不可用。假设我的服务依赖于很多服务，其中一个非核心的依赖如果不可用，而且没有超时机制，那么这个非核心依赖就能拖死我的服务，尽管理论上即使没有它我在大部分情况还能健康运转的。

当我们的服务访问某项依赖有大量超时的时候，再让新的请求去访问已经没有太大意义，那只会无谓的消耗现有资源。即使你已经设置超时1秒了，那明知依赖不可用的情况下再让更多的请求，比如100个，去访问这个依赖，也会导致100个线程1秒的资源浪费。这个时候，断路器就能帮助我们避免这种资源浪费，在自身服务和依赖之间放一个断路器，实时统计访问的状态，当访问超时或者失败达到某个阈值的时候（如50%请求超时，或者连续20次请失败），就打开断路器，那么后续的请求就直接返回失败，不至于浪费资源。断路器再根据一个时间间隔（如5分钟）尝试关闭断路器（或者更换保险丝），看依赖是否恢复服务了。

# 熔断（断路器）

https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern

假设有个应用程序每秒会与数据库沟通数百次，此时数据库突然发生了错误，程序员并不会希望在错误时还不断地访问数据库。因此会在等待TCP连线逾时之前直接处理这个错误，并进入正常的结束程序（而非直接结束程式）。简单来说，断路器会侦测错误并且“预防”应用程序不断地呼叫一个近乎毫无回应的服务（除非该服务已经安全到可重试连线了）。

断路器有分简单与较进阶的版本，简单的断路器只需要知道服务是否可用。而较进阶的版本比起前者更有效率。进阶的断路器带有至少三个状态：

- 关闭：断路器在预设的情形下是呈现关闭的状态，而断路器本身“带有”计数功能，每当错误发生一次，计数器也就会进行“累加”的动作，到了一定的错误发生次数断路器就会被“开启”，这个时候亦会在内部启用一个计时器，一但时间到了就会切换成半开启的状态。
- 开启：在开启的状态下任何请求都会“直接”被拒绝并且抛出异常讯息。
- 半开启：在此状态下断路器会允许部分的请求，如果这些请求都能成功通过，那么就意味着错误已经不存在，则会被“切换回”关闭状态并“重置”计数。倘若请求中有“任一”的错误发生，则会回复到“开启”状态，并且重新计时，给予系统一段休息时间。

# 降级

降级，是配合熔断存在的。对于一些非核心服务，如果出现大量的异常，可以通过技术手段，对服务进行降级并提供有损服务，保证服务的柔性可用，避免引起雪崩效应。

## 降级预案

在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

**一般**：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；

**警告**：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；

**错误**：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；

**严重错误**：比如因为特殊原因数据错误了，此时需要紧急人工降级。

降级按照是否自动化可分为：自动开关降级和人工开关降级。

降级按照功能可分为：读服务降级、写服务降级。

降级按照处于的系统层次可分为：多级降级。

## 降级方式

1. 延迟服务：比如发表了评论，重要服务，比如在文章中显示正常，但是延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行。
2. 在粒度范围内关闭服务（片段降级或服务功能降级）：比如关闭相关文章的推荐，直接关闭推荐区
3. 页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；
4. 页面跳转（页面降级）：比如可以有相关文章推荐，但是更多的页面则直接跳转到某一个地址
5. 写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。
6. 读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景。
