---
layout: post
title: 分离（2）- 读写分离
date: 2020-05-11
categories:
    - 架构设计
comments: true
permalink: read-write-separation.html
---

# 1. 什么是读写分离

读写分离是互联网应用系统中提升数据访问性能最常见的一种技术。

在早期的架构中为了保证可靠性，我们对数据库采用了主从结构部署。主库负责了所有的读写操作，而从库只对主库进行了备份，如果只实现了一个备份，不能读写分离和故障转移，不能降低Master节点的IO压力。这样的主从架构看起来性价比似乎不是很高。

![](/assets/images/posts/read-write-separation/read-write-separation-1.png)

我们所希望的主从架构是，当我们在写数据时，请求全部发到Master节点上，当我们需要读数据时，请求全部发到Slave节点上。并且多个Slave节点最好可以存在负载均衡，让集群的效率最大化。

读写分离基本原理就是将数据库的读写操作分配到不同的节点上。让主数据库处理事务性查询，而从数据库处理SELECT查询。 当然，主服务器也可以提供查询服务。使用读写分离最大的作用无非是缓解服务器压力。

![](/assets/images/posts/read-write-separation/read-write-separation-2.png)

**何种场景下使用读写分离？**

当你在实际业务中遇到以下情形，则可以考虑使用读写分离解决方案。

1. 数据量大；
2. 所有写数据的请求效率尚可；
3. 查询数据的请求效率很低；
4. 所有的数据任何时候都可能被修改；
5. 业务希望我们优化查询数据的功能。

> 读写分离提升了数据库的读性能，但是并没有提升写性能

# 2. 读写分离的实现

## 2.1. 代码层

我们在代码层实现逻辑，对到达的读/写请求进行解析，针对性地分发到不同的数据库中，从而实现读写分离；

1. 注入数据源，包括Master-Slave；
2. 通过拦截器或者AOP，判断一个SQL语句是读还是写；
3. 选择对应的数据源进行执行

这种方法的优势就是比较灵活，我们可以按照自己的逻辑来决定读写分离的规则。，但弊端也显而易见，这样对代码的侵入性太强，当需要对数据源进行增删时，一定会对代码造成影响。这不但会给开发人员造成很大的困扰，而且不符合软件设计的开闭原则。

## 2.2. 中间层

这种方式最主要的特点就是我们在整体架构中新建了一个虚拟节点，所有的请求先到达这个虚拟节点上，由这个虚拟节点来转发读写请求到相应的数据库。

![](/assets/images/posts/read-write-separation/read-write-separation-3.png)

相对于代码层实现，使用中间层的优点十分明显，我们只需要进行配置就可以享受读写分离带来的效率的提升，不用写一行代码。

其缺点当然是需要我们维护这样一个虚拟节点，增加了运维成本。

# 3. 读写分离带来的问题

读写分离会带来**数据一致性问题**。这是由Master-Slave 异步复制存在延迟所导致的，且Master binlog的写入为多线程，而Slave同步的sql_thread为单线程（MySQL5.6之前），两者写入速度不一致，在高并发写入的情况下，Slave节点延迟会更大；

> **数据冗余一定会引发一致性问题。（数据库主从、数据库与缓存）**

## 3.1. 忽略不计

如果业务对于数据一致性要求不高，我们就可以采用这种方案。

## 3.2. 强制读主

对于需要强一致的场景，我们可以将其的读请求都操作主库，这样**读写都在主库**，就没有不一致的情况。

此时为了提升读性能，我们可能会引入缓存机制，此时又会引起数据不一致问题。

![](/assets/images/posts/read-write-separation/read-write-separation-1.png)

## 3.3. 选择性读组

写请求发往主库，同时缓存记录操作的 key，缓存的失效时间设置为主从的延时；

![](/assets/images/posts/read-write-separation/read-write-separation-4.png)

读请求首先判断缓存是否存在：

- 若存在，代表刚发生过写操作，读请求操作主库；
- 若不存在，代表近期没发生写操作，读请求操作从库。

![](/assets/images/posts/read-write-separation/read-write-separation-5.png)