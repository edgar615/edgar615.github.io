---
layout: post
title: Java 垃圾回收机制
date: 2020-01-14
categories:
    - JVM
comments: true
permalink: java-gc.html
---

> 为了整理GC，结果带出了一堆知识点，现在终于整理到这里了，o(╥﹏╥)o
> 本文内容基本来自参考资料

# 什么是自动垃圾回收?

自动垃圾回收是一种在堆内存中找出哪些对象在被使用，还有哪些对象没被使用，并且将后者删掉的机制。

所谓使用中的对象（已引用对象），指的是程序中有指针指向的对象；而未使用中的对象（未引用对象），则没有被任何指针给指向，因此占用的内存也可以被回收掉。

在用 C 之类的编程语言时，程序员需要自己手动分配和释放内存。而 Java 不一样，它有垃圾回收器，释放内存由回收器负责。如何回收其实就是利用哪些算法进行回收，垃圾收集算法分别有：标记-清除算法、复制算法、标记-整理算法、分代回收算法。

# 标记-清除算法
标记－清除（Mark-Sweep） 算法是最基础的垃圾收集算法，后续的收集算法都是基于它的思路并对其不足进行改进而得到的。顾名思义，算法分成“标记”、“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

![](/assets/images/posts/gc/gc-1.jpg)

标记－清除算法的不足主要有以下两点：

- 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。
- 效率问题，因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。

# 复制算法
为了解决标记-清除算法的效率问题，一种称为“复制”（Copying）的收集算法出现了，思想为：它将可用内存按容量分成大小相等的两块，每次只使用其中的一块。当这一块内存用完，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。

这样做使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，代价可能过高了。

![](/assets/images/posts/gc/gc-2.jpg)

# 标记-整理算法

标记-整理算法（Mark-Compact）的标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。

![](/assets/images/posts/gc/gc-3.jpg)

标记-整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。

看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。

从oracle文档中复制的三个图

![](/assets/images/posts/gc/gc-4.png)

![](/assets/images/posts/gc/gc-5.png)

![](/assets/images/posts/gc/gc-6.png)

# 分代收集算法

当前商业虚拟机的垃圾收集都采用分代收集（Generational Collection）算法，此算法严格来说并不是一种思想或理论，而是融合上述 3 种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳，主要思想为：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法：

- 新生代 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
- 老年代 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清除或标记-整理算法来进行回收。

![](/assets/images/posts/gc/gc-7.png)

默认情况下：

- 堆空间= 新生代（1/3）+老年代（2/3）
- 新生代=Eden(8/10)+form(1/10)+to(1/10)

新对象会被分配在新生代内存。一旦新生代内存满了，就会开始对死掉的对象，进行所谓的小型垃圾回收过程。一片新生代内存里，死掉的越多，回收过程就越快；至于那些还活着的对象，此时就会老化，并最终老到进入老年代内存。

Stop the World 事件 —— 小型垃圾回收属于一种叫 "Stop the World" 的事件。在这种事件发生时，所有的程序线程都要暂停，直到事件完成（比如这里就是完成了所有回收工作）为止。

老年代用来保存长时间存活的对象。通常，设置一个阈值，当达到该年龄时，年轻代对象会被移动到老年代。最终老年代也会被回收。这个事件成为 Major GC。

Major GC 也会触发STW（Stop the World）。通常，Major GC会慢很多，因为它涉及到所有存活对象。所以，对于响应性的应用程序，应该尽量避免Major GC。还要注意，Major GC的STW的时长受年老代垃圾回收器类型的影响。

永久代包含JVM用于描述应用程序中类和方法的元数据。永久代是由JVM在运行时根据应用程序使用的类来填充的。此外，Java SE类库和方法也存储在这里。

> JDK8中永久代已经被元空间取代

如果JVM发现某些类不再需要，并且其他类可能需要空间，则这些类可能会被回收。

## Eden 区
IBM 公司的专业研究表明，有将近 98% 的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配。

当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。

通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（**若 From 区不够，则直接进入 Old 区**）。

## Survivor 区
Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为 2 个区：

- From 区
- To 区

每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（**如果 To 区不够，则直接进入 Old 区**）。

Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。

设置两个 Survivor 区最大的好处就是解决内存碎片化。我们先假设一下，Survivor 如果只有一个区域会怎样。

Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。

因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。

这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。

## Old 区
老年代占据着 2/3 的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记-整理算法。

除了上述所说，在内存担保机制下，无法安置的对象会直接进到老年代，以下几种情况也会进入老年代。

**大对象**

大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。
这样做主要是为了避免在 Eden 区及 2 个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。

**长期存活对象**

虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。当年龄增加到 15 岁时，这时候就会被转移到老年代。当然，这里的 15，JVM 也支持通过`MaxTenuringThreshold`参数进行设置。

> MaxTenuringThreshold的最大值就是15，因为对象头里就给了它4个bit来存放，因此最大值就是1111=15

**动态对象年龄**

虚拟机并不重视要求对象年龄必须到 15 岁，才会放入老年区，**如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。**

> CMS GC下默认是6

## 分代垃圾收集过程
首先，将任何新对象分配给 eden 空间。两个 survivor 空间都是空的。

![](/assets/images/posts/gc/gc-8.png)

当 eden 空间填满时，会触发轻微的垃圾收集。

![](/assets/images/posts/gc/gc-9.png)

引用的对象被移动到第一个 survivor 空间。清除 eden 空间时，将删除未引用的对象。

![](/assets/images/posts/gc/gc-10.png)

在下一次Minor GC中，Eden区也会做同样的操作。删除未被引用的对象，并将被引用的对象移动到Survivor区。然而，这里，他们被移动到了第二个Survivor区（S1）。此外，第一个Survivor区（S0）中，在上一次Minor GC幸存的对象，会增加年龄，并被移动到S1中。待所有幸存对象都被移动到S1后，S0和Eden区都会被清空。注意，Survivor区中有了不同年龄的对象。

![](/assets/images/posts/gc/gc-11.png)

在下一次Minor GC中，会重复同样的操作。不过，这一次Survivor区会交换。被引用的对象移动到S0,。幸存的对象增加年龄。Eden区和S1被清空。

![](/assets/images/posts/gc/gc-12.png)

在较小的GC之后，当老化的对象达到一定的年龄阈值（在该示例中为8）时，它们从年轻一代晋升到老一代。

![](/assets/images/posts/gc/gc-13.png)

随着较小的GC持续发生，对象将继续被推广到老一代空间。

![](/assets/images/posts/gc/gc-14.png)

所以这几乎涵盖了年轻一代的整个过程。最终，将主要对老一代进行GC，清理并最终压缩该空间。

![](/assets/images/posts/gc/gc-15.png)

# GC 事件分类

根据垃圾收集回收的区域不同，垃圾收集主要分为：

- Young GC
- Old GC
- Full GC
- Mixed GC

**Young GC**

新生代内存的垃圾收集事件称为 Young GC（又称 Minor GC），当 JVM 无法为新对象分配在新生代内存空间时总会触发 Young GC。

比如 Eden 区占满时，新对象分配频率越高，Young GC 的频率就越高。

Young GC 每次都会引起全线停顿（Stop-The-World），暂停所有的应用线程，停顿时间相对老年代 GC 造成的停顿，几乎可以忽略不计。

大部分Eden中的对象都能被认为是垃圾，永远不会复制到Survivor区或者老年代，但是如果正好相反Eden中的大部分新生对象不符合GC条件，Yong GC暂停的时间将会很长

**Old GC：**

只清理老年代空间的 GC 事件，只有 CMS 的并发收集是这个模式。又称（Major GC）

**Full GC：**

清理整个堆的 GC 事件，包括新生代、老年代、元空间等 。

实际上很多Major GC都是由Minor GC触发的，所以很多情况

**Mixed GC：**

清理整个新生代以及部分老年代的 GC，只有 G1 有这个模式。


# 参考资料

https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html

https://mp.weixin.qq.com/s/qe74YJiiUBUx_Q7Dfd_uRg