---
layout: post
title: MySQL锁(2)-死锁
date: 2019-06-10
categories:
    - MySQL
comments: true
permalink: innodb-dead-lock.html
---


# 1. 死锁
**死锁产生**

- 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环
- 当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁
-  锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。

**检测死锁**

数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。

**死锁恢复**

死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。

**外部锁的死锁检测**

发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数`innodb_lock_wait_timeout`来解决 

**死锁影响性能**

死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用`innodb_deadlock_detect`配置选项）可能会更有效，这时可以依赖`innodb_lock_wait_timeout`设置进行事务回滚。 

# 2. 唯一索引冲突引发的死锁

并发条件下，唯一键索引冲突可能会导致死锁，这种死锁一般分为两种，一种是`rollback`引发，另一种是`commit`引发。

## 2.1.  `rollback`引发的死锁

开启3个事务，都执行下面的insert

```
INSERT INTO user (id, username, nickname, gender, age) VALUES (10, 'username10', 'nickname10', 2, 10);
```

可以看到3个事务都需要对记录10加锁，不同的事务1加的X锁，事务2，事务3加的S锁（此时事务2和事务3插入数据时检测到了重复键错误，事务2和事务3要在这条索引记录上设置S锁，由于X锁的存在，S锁的获取被阻塞。）

```
+------+---------------------------------------+---------------------+---------+--------+-------------+-----------+--------------+-----------------+----------+---------------------+---------+-------------+-----------+---------+
|ENGINE|ENGINE_LOCK_ID                         |ENGINE_TRANSACTION_ID|THREAD_ID|EVENT_ID|OBJECT_SCHEMA|OBJECT_NAME|PARTITION_NAME|SUBPARTITION_NAME|INDEX_NAME|OBJECT_INSTANCE_BEGIN|LOCK_TYPE|LOCK_MODE    |LOCK_STATUS|LOCK_DATA|
+------+---------------------------------------+---------------------+---------+--------+-------------+-----------+--------------+-----------------+----------+---------------------+---------+-------------+-----------+---------+
|INNODB|140622813693800:1174:140622732294672   |25160586             |108      |14      |ed_test      |user       |NULL          |NULL             |NULL      |140622732294672      |TABLE    |IX           |GRANTED    |NULL     |
|INNODB|140622813693800:117:4:6:140622732291568|25160586             |108      |14      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732291568      |RECORD   |S,REC_NOT_GAP|WAITING    |10       |
|INNODB|140622813692952:1174:140622732288576   |25160585             |107      |21      |ed_test      |user       |NULL          |NULL             |NULL      |140622732288576      |TABLE    |IX           |GRANTED    |NULL     |
|INNODB|140622813692952:117:4:6:140622732285472|25160585             |107      |21      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732285472      |RECORD   |S,REC_NOT_GAP|WAITING    |10       |
|INNODB|140622813691256:1174:140622732276320   |25160584             |104      |35      |ed_test      |user       |NULL          |NULL             |NULL      |140622732276320      |TABLE    |IX           |GRANTED    |NULL     |
|INNODB|140622813691256:117:4:6:140622732273216|25160584             |107      |21      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732273216      |RECORD   |X,REC_NOT_GAP|GRANTED    |10       |
+------+---------------------------------------+---------------------+---------+--------+-------------+-----------+--------------+-----------------+----------+---------------------+---------+-------------+-----------+---------+


+------+---------------------------------------+--------------------------------+--------------------+-------------------+--------------------------------+---------------------------------------+------------------------------+------------------+-----------------+------------------------------+
|ENGINE|REQUESTING_ENGINE_LOCK_ID              |REQUESTING_ENGINE_TRANSACTION_ID|REQUESTING_THREAD_ID|REQUESTING_EVENT_ID|REQUESTING_OBJECT_INSTANCE_BEGIN|BLOCKING_ENGINE_LOCK_ID                |BLOCKING_ENGINE_TRANSACTION_ID|BLOCKING_THREAD_ID|BLOCKING_EVENT_ID|BLOCKING_OBJECT_INSTANCE_BEGIN|
+------+---------------------------------------+--------------------------------+--------------------+-------------------+--------------------------------+---------------------------------------+------------------------------+------------------+-----------------+------------------------------+
|INNODB|140622813693800:117:4:6:140622732291568|25160586                        |108                 |14                 |140622732291568                 |140622813691256:117:4:6:140622732273216|25160584                      |107               |21               |140622732273216               |
|INNODB|140622813692952:117:4:6:140622732285472|25160585                        |107                 |21                 |140622732285472                 |140622813691256:117:4:6:140622732273216|25160584                      |107               |21               |140622732273216               |
+------+---------------------------------------+--------------------------------+--------------------+-------------------+--------------------------------+---------------------------------------+------------------------------+------------------+-----------------+------------------------------+

```

此时对事务1执行`rollback`，事务2和事务3发生了死锁。

事务1回滚，由于S锁和S锁是可以兼容的，因此事务2和事务3都获得了这条记录的S锁，此时其中一个事务希望插入，则该事务期望在这条记录上加上X锁，然而另一个事务持有S锁，S锁和X锁互相是不兼容的，两个事务就开始互相等待对方的锁释放，造成了死锁。

**事务2和事务3为什么会加S锁，而不是直接等待X锁**

事务1的insert语句加的是隐式锁(隐式的Record锁、X锁)，但是其他事务插入同一行记录时，出现了唯一键冲突，事务一的隐式锁升级为显示锁。
事务2和事务3在插入之前判断到了唯一键冲突，是因为插入前的**重复索引检查**，这次检查必须进行一次**当前读**，**于是非唯一索引就会被加上S模式的next-key锁，唯一索引就被加上了S模式的Record锁。**
因为插入和更新之前都要进行重复索引检查而执行当前读操作，所以RR隔离级别下，同一个事务内不连续的查询，可能也会出现幻读的效果(但个人并不认为RR 级别下也会出现幻读，幻读的定义应该是连续的读取)。而连续的查询由于都是读取快照，中间没有当前读的操作，所以不会出现幻读。

## 2.2. `commit`引发的死锁

事务1执行删除

```
delete from user where id = 1;
```

事务2和事务3执行新增相同的ID

```
INSERT INTO user (id, username, nickname, gender, age) VALUES (1, 'username10', 'nickname10', 2, 10);
```

事务1执行commit的时候，事务2和事务3发生了死锁。原因和上面相同

# 3. 先insert在update引发的死锁

## 3.1. update非索引字段

一个事务内：insert记录后根据字段p（非索引字段）来update这条记录，然而当出现并发操作的时候，update处会发生dead lock问题

事务1

```

mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> INSERT INTO user (id, username, nickname, gender, age) VALUES (10, 'username10', 'nickname10', 2, 10);
Query OK, 1 row affected (0.01 sec)

```

事务2

```

mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> INSERT INTO user (id, username, nickname, gender, age) VALUES (11, 'username11', 'nickname11', 2, 11);
Query OK, 1 row affected (0.01 sec)

```

事务1

```
mysql> update user set gender = 1 where nickname = 'nickname10';
// 等待锁
```

事务2

```
mysql> update user set gender = 1 where nickname = 'nickname11';
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

查看锁

```
+------+---------------------------------------+---------------------+---------+--------+-------------+-----------+--------------+-----------------+----------+---------------------+---------+-------------+-----------+---------+
|ENGINE|ENGINE_LOCK_ID                         |ENGINE_TRANSACTION_ID|THREAD_ID|EVENT_ID|OBJECT_SCHEMA|OBJECT_NAME|PARTITION_NAME|SUBPARTITION_NAME|INDEX_NAME|OBJECT_INSTANCE_BEGIN|LOCK_TYPE|LOCK_MODE    |LOCK_STATUS|LOCK_DATA|
+------+---------------------------------------+---------------------+---------+--------+-------------+-----------+--------------+-----------------+----------+---------------------+---------+-------------+-----------+---------+
|INNODB|140622813692952:1175:140622732288576   |25160670             |107      |59      |ed_test      |user       |NULL          |NULL             |NULL      |140622732288576      |TABLE    |IX           |GRANTED    |NULL     |
|INNODB|140622813692952:118:4:6:140622732285472|25160670             |104      |94      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732285472      |RECORD   |X,REC_NOT_GAP|GRANTED    |11       |
|INNODB|140622813691256:1175:140622732276320   |25160669             |104      |93      |ed_test      |user       |NULL          |NULL             |NULL      |140622732276320      |TABLE    |IX           |GRANTED    |NULL     |
|INNODB|140622813691256:118:4:2:140622732273216|25160669             |104      |94      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732273216      |RECORD   |X            |GRANTED    |1        |
|INNODB|140622813691256:118:4:3:140622732273216|25160669             |104      |94      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732273216      |RECORD   |X            |GRANTED    |3        |
|INNODB|140622813691256:118:4:4:140622732273216|25160669             |104      |94      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732273216      |RECORD   |X            |GRANTED    |5        |
|INNODB|140622813691256:118:4:5:140622732273216|25160669             |104      |94      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732273216      |RECORD   |X            |GRANTED    |7        |
|INNODB|140622813691256:118:4:7:140622732273560|25160669             |104      |94      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732273560      |RECORD   |X,REC_NOT_GAP|GRANTED    |10       |
|INNODB|140622813691256:118:4:7:140622732273904|25160669             |104      |94      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732273904      |RECORD   |X,GAP        |GRANTED    |10       |
|INNODB|140622813691256:118:4:6:140622732274248|25160669             |104      |94      |ed_test      |user       |NULL          |NULL             |PRIMARY   |140622732274248      |RECORD   |X            |WAITING    |11       |
+------+---------------------------------------+---------------------+---------+--------+-------------+-----------+--------------+-----------------+----------+---------------------+---------+-------------+-----------+---------+

```

发现两个事务锁定同一个记录11.

1. 事务1的insert产生了一个插入意向锁，事务2的insert也产生了一个插入意向锁（不会被互相锁住，因为数据行并不冲突）
2. 此时事务1再进行update语句，因未走索引，导致扫全表，而在扫到事务2插入那条数据时，行锁与插入意向锁冲突了，导致事务1需要等待事务2释放插入意向锁而进行等待。
3. 事务2在进行update时，也同样需要扫全表，但是全表都被事务1的update锁住了，事务2需要等待 `等待事务2释放插入意向锁的` 事务1 的行锁 释放，因此发生了死锁

如果我们使用索引字段age来更新，就不会出现死锁



# 2. InnoDB避免死锁：

死锁在行锁及事务场景下很难完全消除，但可以通过表设计和SQL调整等措施减少锁冲突和死锁，包括：

- 尽量使用较低的隔离级别，比如如果发生了间隙锁，你可以把会话或者事务的事务隔离级别更改为 RC(read committed)级别来避免，但此时需要把 binlog_format 设置成 row 或者 mixed 格式
- 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；
- 选择合理的事务大小，小事务发生锁冲突的几率也更小；
- 给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；
- 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；

如果出现死锁，可以用 `SHOW ENGINE INNODB STATUS` 命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。

