---
layout: post
title: RPC简介
date: 2020-05-15
categories:
    - rpc
comments: true
permalink: rpc-intro.html
---

> 还没整理完

# 1. RPC
RPC（Remote Procedure Call），即远程过程调用，是一个分布式系统间通信的必备技术。*分布式系统中的网络通信一般都会采用四层的TCP协议或七层的HTTP协议*

HTTP协议，以其中的Restful规范为代表，它可读性好，且可以得到防火墙的支持、跨语言的支持。缺点是有用信息占比少，效率低，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。

RPC 最核心要解决的问题就是在分布式系统之间间，如何执行另外一个地址空间上的函数，就仿佛在本地调用一样。

- 屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法
- 隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。

一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“RPC 协议”就指明了程序如何进行网络传输和序列化。

![](/assets/images/posts/rpc-intro/rpc-intro-1.jpg)

# 2. RPC核心功能
RPC 的核心功能是指实现一个 RPC 最重要的功能模块，就是上图中的”RPC 协议”部分

![](/assets/images/posts/rpc-intro/rpc-intro-3.jpg)

要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个RPC调用的流程涉及到哪些通信细节：

![](/assets/images/posts/rpc-intro/rpc-intro-2.png)

1. 服务消费者(Client 客户端)通过本地调用的方式调用服务。
2. 客户端存根(Client Stub)接收到调用请求后负责将方法、入参等信息序列化(组装)成能够进行网络传输的消息体。
3. 客户端存根(Client Stub)找到远程的服务地址，并且将消息通过网络发送给服务端。
4. 服务端存根(Server Stub)收到消息后进行解码(反序列化操作)。
5. 服务端存根(Server Stub)根据解码结果调用本地的服务进行相关处理
6. 服务端(Server)本地服务业务处理。
7. 处理结果返回给服务端存根(Server Stub)。
8. 服务端存根(Server Stub)序列化结果。
9. 服务端存根(Server Stub)将结果通过网络发送至消费方。
10. 客户端存根(Client Stub)接收到消息，并进行解码(反序列化)。
11. 服务消费方得到最终结果。

RPC的目标就是要2~10这些步骤都封装起来，让用户对这些细节透明。

上图也说明了RPC核心的重要组成：

1. 客户端(Client)：服务调用方。
2. 客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。
3. 服务端存根(Server Stub)：接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。
4. 服务端(Server)：服务的真正提供者。
5. Network Service：底层传输，可以是 TCP 或 HTTP
    
RPC 核心功能实现技术点

    透明化远程服务调用：字节码生成，JDK动态代理
    编码与解码
    服务寻址：Call ID 映射，可以直接使用函数字符串，也可以使用整数 ID。映射表一般就是一个哈希表。
    数据流的序列化和反序列化：可以自己写，也可以使用 Protobuf 或者 FlatBuffers 之类的。
    网络传输：可以自己写 Socket，或者用 Asio，ZeroMQ，Netty 之类。在 RPC 中可选的网络传输方式有多种，可以选择 TCP 协议、UDP 协议、HTTP 协议

透明化远程服务调用（代理）

    jdk 动态代理：更多使用动态代理
    字节码生成：更为强大和高效，但代码维护不易

服务寻址（服务注册中心）

    实现方式：服务注册中心。

    Call ID 映射

RPC的三个基本问题：Call ID 映射、序列化和反序列化、网络传输。

Call ID 映射

不知道上面的例子有没有很好的解释Call ID 映射、序列化和反序列化、网络传输是什么东西。将上述例子类比到项目中，我们就能很好的理解为什么需要解决这些问题了。

类比本地调用函数，我们需要知道函数名，Call ID 就类似于这样的标志，只有这样才知道你需要的调用的是什么。如果没有 Call ID，我们就无法得知需要调用的方法是什么。

所以，在 RPC 中，所有的函数都必须有自己的一个 ID。这个 ID 在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一个 {函数 - >Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的 Call ID 必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。

实现一个高性能高可靠的RPC框架需要解决哪些问题？

1.应用都基于微服务化，实现资源调用离不开远程调用

2.一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？--- 这时候就需要一个服务注册中心，从服务注册中心获取服务的实例列表，再从中选择一个进行调用。

3.选哪个调用好呢？这时候就需要负载均衡了，于是又得考虑如何实现复杂均衡

4.总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题

5.客户端总不能每次调用完都干等着服务端返回数据吧,于是就要支持异步调用;

6.服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；

7.服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；

8.服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？

https://www.zhihu.com/question/298707085/answer/1249221512

https://zhuanlan.zhihu.com/p/148044947

https://www.cnblogs.com/haimishasha/p/11573512.html

https://www.cnblogs.com/crazylqy/p/7995395.html

https://developer.51cto.com/art/201906/597963.htm
