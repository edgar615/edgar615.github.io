---
layout: post
title: 消息队列
date: 2020-04-16
categories:
    - 架构设计
comments: true
permalink: mq.html
---

# 1. 消息队列特性

- 业务无关，只做消息分发。
- FIFO，先投递先到达。
- 容灾：节点动态增删和消息持久化。
- 性能：吞吐量提升，系统内部通信效率提高。

#  2. 消息队列的作用

- **削峰填谷：**削峰填谷是消息队列最主要的作用，但是会造成请求处理的延迟。
- **异步：**异步处理是提升系统性能的神器，但是你需要分清同步流程和异步流程的边界，同时消息存在着丢失的风险，我们需要考虑如何确保消息一定到达。
- **解耦：**解耦合可以提升你的整体系统的鲁棒性。

## 2.1. 异步

消息的生产者将消息发送到消息队列以后，由消息的消费者从消息队列中获取消息，然后进行业务逻辑的处理，消息的生产者和消费者是异步处理的，彼此不会等待阻塞，所以叫做异步架构。

![](/assets/images/posts/mq/mq-5.png)

假设这样一个场景，用户下单成功需要给用户发短信，如果没有消息队列，我们会选择同步调用发短信的接口并等待短信发送成功。

![](/assets/images/posts/mq/mq-1.png)

我们忽略中间的网络通信时间消耗，假如订单系统处理需要 150ms，短信系统处理需要 200ms，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。

假如再加一个发送邮件，这样整个系统的调用链又变长了，整个时间就变成了550ms。

![](/assets/images/posts/mq/mq-2.png)

如果使用 MQ，那么订单系统连续发送一条消息到消息队列中，假如耗时 5ms，短息系统和邮件系统从消息队列中异步读取消息，那么对于用户来说，用户的响应时间就变成了155ms

![](/assets/images/posts/mq/mq-3.png)

对一些比较耗时的操作，我们可以把处理过程通过消息队列进行异步处理。这样做一个显而易见的好处就是，可以推迟耗时操作的处理，使耗时操作异步化，而不必阻塞客户端的程序，客户端的程序在得到处理结果之前就可以继续执行，从而提高客户端程序的处理性能。

## 2.2.  解耦

依然以上面的用户下单的例子为例，最初的伪代码如下

```
void order() {
    // 创建订单
    createOrder();
    // RPC发送短信
    sendSms();
}
```

那么我们又添加了一个发送邮件，就得重新去修改代码

```
void order() {
    // 创建订单
    createOrder();
    // RPC发送短信
    sendSms();
    // RPC发送邮件
    sendMail();
}
```

如果在后面再增加增加积分、送券等业务呢？

```
void order() {
    // 创建订单
    createOrder();
    // RPC发送短信
    sendSms();
    // RPC发送邮件
    sendMail();
    // RPC增加积分 
    addPoints();
    // RPC增加券
    addCoupons();
}
```

一个大规模系统，往往会拆分为几十个甚至上百个子系统，每个子系统又对应N多个服务，这些系统与系统之间有着错综复杂的关系网络。如果某个系统产出一份核心数据，可能下游无数的其他系统都需要这份数据来实现各种业务逻辑。

此时如果你要是采取上面那种模式来设计订单系统，负责订单系统的人估计会被烦死。那么此时我们就可以用一个消息队列在中间进行解耦。订单系统只需要发送一个下单成功的消息到消息队列，下游哪个系统感兴趣自己去消费即可

![](/assets/images/posts/mq/mq-4.png)

使用分布式消息队列，可以使生产者和消费者的代码实现解耦合，也就是说可以多个生产者发布消息，多个消费者处理消息，共同完成完整的业务处理逻辑，但是它们却不需要直接进行交互调用，没有代码的依赖耦合。在传统的同步调用中，调用者代码必须要依赖被调用者的代码，也就是生产者代码必须要依赖消费者的处理逻辑代码，代码需要直接的耦合，而使用消息队列，这两部分的代码不需要进行任何的耦合。耦合程度越低的代码越容易维护，也越容易进行扩展。

解耦的特点对于团队的工作分工也很有帮助。从消息生产者的视角看，它只需要构建消息，将消息放入消息队列中，开发就完成了；而从消费者的开发视角看，它只需要从消息队列中获取消息，然后进行逻辑处理。它们彼此之间不进行任何耦合。消息的生产者不关心放入消息队列中下一步会发生什么，而消费者也不需要知道消息从哪里来。这两部分程序的开发者也可以不关心彼此的工作进展，他们开发的代码也不需要集成在一起，只要约定好消息格式，就可以各自开发了。

## 2.3. 削峰填谷

上下游对于事情的处理能力是不同的，例如Web前端通过LVS和nginx每秒可以承受上千万的请求。但数据库的处理能力却十分有限，即使使用SSD加分库分表，单机的处理能力仍然在万级，我们不能奢求数据库的机器数量追上前端。

这种问题同样存在于系统和系统之间，如短信系统的速度可能卡在第三方短信平台（每秒几百次请求）。因为订单系统是我们的核心业务，所以它的配置可能会好一些，假设订单系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而短信系统并不是我们的主要业务，所以我们配备的硬件资源并不会太高，在加上第三方短信平台的限制，所有短信平台可能并不能承受一万次请求。

因为短信业务又不是我们的主业务，而且用户晚上个半分钟左右收到短信，一般是不会有太大问题的。我们可以把下单完成的信息发送到消息队列中，而短信系统尽自己所能地去消息队列中取消息和消费消息，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。

这样的结果可能就是在高峰期消息队列中挤压了大量的消息，但等高峰期过了之后，短信系统就会快速将积压的消息给解决掉，这就是填谷。

![](/assets/images/posts/mq/mq-7.png)

在访问高峰，用户的并发访问数可能超过了系统的处理能力，所以在高峰期就可能会导致系统负载过大，响应速度变慢，更严重的可能会导致系统崩溃。这种情况下，通过消息队列将用户请求的消息纳入到消息队列中，通过消息队列缓冲消费者处理消息的速度。 

如图中所示，消息的生产者负载有高峰有低谷，但是到了消费者这里，只会按照自己的最佳处理能力去消费消息。高峰期它会把消息缓冲在消息队列中，而在低谷期它也还是使用自己最大的处理能力去获取消息，将前面缓冲起来、来不及及时处理的消息处理掉。那么，通过这种手段可以实现系统负载削峰填谷，也就是说将访问的高峰削掉，而将访问的低谷填平，使系统处在一个最佳的处理状态之下，不会对系统的负载产生太大的冲击。

# 3. 消息队列的挑战

- **消息无序**

先来说消息无序。因为生产者和消费者是异步处理的。虽然消息队列本身会保证先创建的消息在前面，但是消费者却并不能保证先创建的消息先消费掉。

- 重复消费

其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同。

因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。

解决这个问题的主要手段是将消息处理设计成幂等性，也就是说消费者可以对同一条消息进行多次处理计算，而不会影响最终的结果。

>  在收到消息后先将消息持久化到本地数据库，通过数据库的唯一性校验避免出现重复消费的情况。

- 系统可用性降低

加入消息队列后，就会增加了一个风险因素：如果消息队列挂了，系统的运行就不对了，可用性降低

- 系统复杂性增加

消息队列使系统的架构和处理流程更加复杂，带来了更多的复杂性问题，如重复消息、消息丢失、消费顺序性等问题，为了解决这些问题，又需要引入很多复杂的机制，从而也对架构师的系统架构设计能力和架构把控能力提出了更高的挑战和要求。

- 数据一致性问题

A 系统发送完消息后直接返回成功了，此时C系统读取消息写数据库的时候失败了，就会产生数据不一致问题

# 4. 死信队列
一般生产环境中，都会在使用MQ的时候设计两个队列：一个是核心业务队列，一个是死信队列。

核心业务队列，就是比如上面专门用来让订单系统发送订单消息的，然后另外一个**死信队列就是用来处理异常情况的**。

比如说要是第三方物流系统故障了，此时无法请求，那么仓储系统每次消费到一条订单消息，尝试通知发货和配送，都会遇到对方的接口报错。此时仓储系统就可以把这条消息拒绝访问，或者标志位处理失败！注意，这个步骤很重要。

一旦标志这条消息处理失败了之后，MQ就会把这条消息转入提前设置好的一个死信队列中。在第三方物流系统故障期间，所有订单消息全部处理失败，全部会转入死信队列。

然后仓储系统开启一个后台线程，监控第三方物流系统是否正常，能否请求的，不停的监视。一旦发现对方恢复正常，这个后台线程就从死信队列消费出来处理失败的订单，重新执行发货和配送的通知逻辑。

死信队列的使用，其实就是MQ在生产实践中非常重要的一环，也就是架构设计必须要考虑的。

# 5. 参考资料

《架构师的 36 项修炼 》