---
layout: post
title: 并发
date: 2019-06-24
categories:
    - java,多线程
comments: true
permalink: java-concurrency.html
---

# 竞态条件
当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。
多个线程同时更新共享资源会引发竞态条件。
最常见的竞态条件就是“先检查后执行(Check-Then-Act)”操作，即通过一个可能失效的观测结果来决定下一步的动作。

导致竞态条件发生的代码区称作**临界区**。

**延迟初始化中的竞态条件**

```
@NotThreadSafe
public class LazyInitRace {

	private ExpensiveObject instance = null;

	public ExpensiveObject getInstance() {
        if (instance == null) {
			instance = new ExpensiveObject();
		}
		return instance;
	}
}
```

线程A和B同时执行getInstance，A看的instance是null，并创建一个新的ExpensiveObject。同时B也在检查instance是否为null。此时此刻的instance是否为null，这依赖于不可预测的时序，
包括线程的调度方式，以及A需要花多长时间来初始化ExpensiveObject并设置instance。如果当B检查时，instance为空，那么在两次调用getInstance时可能会得到不同的结果，即使getInstance通常被认为是返回相同的实例。

**当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区**
和大多数并发错误一样，竞态条件并不总是会产生错误，还需要某种不恰当的执行时序。

# CPU三级缓存
计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存（物理内存）当中的。但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。

为了避免内存成为计算机处理的瓶颈，我们在CPU和内存之间增加高速缓存：

![](/assets/images/posts/concurrency/concurrency-1.png)

**当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中**

在高速缓存出现后不久，系统变得越来越复杂，高速缓存与主存之间的速度差异被拉大，直到加入了另一级缓存，新加入的这级缓存比第一缓存更大，但是更慢，而且经济上不合适，所以有了二级缓存，甚至有些系统已经拥有了三级缓存，于是就演变成了多级缓存。这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。

![](/assets/images/posts/concurrency/concurrency-2.png)

L1最靠近CPU核心；L2其次；L3再次。在运行速度方面：L1最快、L2次快、L3最慢；在容量大小方面：L1最小、L2较大、L3最大

当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。

## 缓存一致性
多级缓存-缓存一致性（MESI），MESI是一个协议，这协议用于保证多个CPU cache之间缓存共享数据的一致性。它定义了CacheLine的四种数据状态，而CPU对cache的四种操作可能会产生不一致的状态。因此缓存控制器监听到本地操作与远程操作的时候需要对地址一致的CacheLine状态做出一定的修改，从而保证数据在多个cache之间流转的一致性。CacheLine的四种状态如下：

- M: Modified 修改，指的是该缓存行只被缓存在该CPU的缓存中，并且是被修改过的，因此他与主存中的数据是不一致的， 该缓存行中的数据需要在未来的某个时间点（允许其他CPU读取主存相应中的内容之前）写回主存，而当数据被写回主存之后，该缓存行的状态会变成E（独享）
- E：Exclusive 独享 缓存行只被缓存在该CPU的缓存中，是未被修改过的，与主存的数据是一致的，可以在任何时刻当有其他CPU读取该内存时，变成S（共享）状态，同样的当CPU修改该缓存行的内容时，会变成M（被修改）的状态
- S：Share 共享，当前CPU和其他CPU中都有共同数据，并且和主存中的数据一致；意味着该缓存行可能会被多个CPU进行缓存，并且各缓存中的数据与主存数据是一致的，当有一个CPU修改该缓存行时，在其他CPU中的该缓存行是可以被作废的，变成I(无效的) 状态
- I：Invalid 无效的，代表这个缓存是无效的，可能是有其他CPU修改了该缓存行；数据应该从主存中获取，其他CPU中可能有数据也可能无数据，当前CPU中的数据和主存被认为是不一致的；对于invalid而言，在MESI协议中采取的是写失效（write invalidate）。

CacheLine有四种数据状态（MESI），而引起数据状态转换的CPU cache操作也有四种：

- local read：读本地缓存中的数据
- local write：将数据写到本地缓存里面
- remote read：将内（主）存中的数据读取到缓存中来
- remote write：将缓存中的数据写回到主存里面去

在一个典型的多核系统中，每一个核都会有自己的缓存来共享主存总线，每个相应的CPU会发出读写（I/O）请求，而缓存的目的是为了减少CPU读写共享主存的次数。一个缓存除了在 Invalid 状态之外，都可以满足CPU的读请求。

一个写请求只有在该缓存行是M状态，或者E状态的时候才能够被执行。如果当前状态是处在S状态的时候，它必须先将缓存中的该缓存行变成无效的（Invalid）状态，这个操作通常作用于广播的方式来完成。这个时候它既不允许不同的CPU同时修改同一个缓存行，即使修改该缓存行不同位置的数据也是不允许的，这里主要解决的是缓存一致性的问题。一个处于M状态的缓存行它必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S状态之前被延迟执行。

一个处于S状态的缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。

一个处于E状态的缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S状态。

因此，对于M和E两种状态而言总是精确的，他们在和该缓存行的真正状态是一致的。而S状态可能是非一致的，如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。

从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。

## 指令重排序
指令重排序处理器为提高运算速度而做出违背代码原有顺序的优化。
例如代码
```
a=10;
b=200;
result=a*b;
```
在CPU重排序后可能变为
```
b=200;
a=10;
result=a*b;
```

可以看到CPU重排序执行优化后的代码并不会对计算结果造成影响，但这也只是其中一种没被影响的情况而已。在单核时代，处理器保证做出的优化不会导致执行结果远离预期目标。但是在多核环境下则并非如此，因为在多核环境下同时会有多个核心在执行指令，每个核心的指令都可能被乱序。另外处理器还引入了L1、L2等多级缓存机制，而每个核心都有自己的缓存，这就导致了逻辑次序上后写入的数据未必真的写入了。如果我们不做任何防护措施，那么处理器最终处理的结果可能与我们代码的逻辑结果大不相同。比如我们在一个核心上执行数据写入操作，并在最后写一个标记用来表示之前的数据已经准备好了。然后从另外一个核心上通过判断这个标记来判定所需要的数据是否已准备就绪，这种做法就存在一定的风险，标记位可能先被写入，而数据并未准备完成，这个未完成既有可能是没有计算完成，也有可能是缓存没有被及时刷新到主存之中，这样最终就会导致另外的核心使用了错误的数据，所以我们才经常在多线程的情况下保证线程安全。

# java内存模型
Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。

Java内存模型把Java虚拟机内部划分为线程栈和堆。

![](/assets/images/posts/concurrency/concurrency-3.png)


- Head（堆）：java里的堆是一个运行时的数据区，堆是由垃圾回收机制来负责的。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，而且Java的垃圾回收机制也会自动的收走那些不再使用的数据。但是它也有缺点，由于是运行时动态分配内存，因此它的存取速度相对要慢一些。
- Stack（栈）：栈的优势是存取速度比堆要快，仅次于计算机里的寄存器，栈的数据是可以共享的。而栈的缺点则是存在栈中的数据的大小以及生存期必须是确定的，缺乏一些灵活性，所以栈中主要用来存储一些基本数据类型的变量，比如：int，short，long，byte，double，float，boolean，char以及对象句柄等。

每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。

所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。

堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。

一个本地变量也可能是指向一个对象的引用，这种情况下这个保存对象引用的本地变量是存放在线程栈上的，但是对象本身则是存放在堆上的。

一个对象可能包含方法，而这些方法可能包含着本地变量，这些本地变量仍然是存放在线程栈上的。即使这些方法所属的对象是存放在堆上的。一个对象的成员变量，可能会随着所属对象而存放在堆上，不管这个成员变量是原始类型还是引用类型。静态成员变量则是随着类的定义一起存放在堆上。

存放在堆上的对象，可以被持有这个对象的引用的线程访问。当一个线程可以访问某个对象时，它也可以访问该对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，那么它们都将会访问这个方法中的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。

## 线程和主存的关系

![](/assets/images/posts/concurrency/concurrency-4.png)

每个线程之间的共享变量存储在主内存里面，每个线程都有一个私有的本地内存，本地内存是Java内存模型的一个抽象的概念，并不是真实存在的。它涵盖了缓存、写缓存区、寄存器以及其他的硬件和编译器的优化，本地内存中存储了该线程已读或写共享变量的拷贝的一个副本。

从一个更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。

Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而JVM的静态内存存储模型（JVM内存模型）只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。

如果上图中的线程A和线程B要通信，必须经历两个步骤：

- 首先线程A要把本地内存A中更新过的共享变量刷新到主内存里
- 然后线程B再到主内存中去读取线程A更新的共享变量，这样就完成了两个线程之间的通信了

因此，多线程的环境下就会出现线程安全问题。例如我们要进行一个计数的操作：线程A在主内存中读取到了变量值为1，然后保存到本地内存A中进行累加。就在此时线程B并没有等待线程A把累加后的结果写入到主内存中再进行读取，而是在主内存中直接读取到了变量值为1，然后保存到本地内存B中进行累加。此时，两个线程之间的数据是不可见的，当两个线程同时把计算后的结果都写入到主内存中，就导致了计算结果是错误的。

![](/assets/images/posts/concurrency/concurrency-5.png)

这种情况下，我们就需要采取一些同步的手段，确保在并发环境下，程序处理结果的准确性。

采取同步手段时的八种操作

- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态
- unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load（载入）：作用于主内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
- use（使用）：作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用某个变量的字节码指定时就会执行这个操作
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指定时就会执行这个操作
- store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作能够使用
- write（写入）：作用于工作内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中

![](/assets/images/posts/concurrency/concurrency-6.png)

如果要把一个变量从主内存中复制到工作内存，就需要按顺序的执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序的执行store和write操作。**但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。**

- 不允许read和load、store和write操作之一单独出现
- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
- 不允许一个线程无原因的（没有发生过任何assign操作）把数据从工作内存同步回主内存中
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assin）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了load或assin操作。
- 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。所以lock和unlock必须成对出现。
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）

## 实现

在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。

下面我们看下，在Java中分别使用什么方式来保证原子性、有序性和一致性的问题

**原子性**

在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。这两个字节码，在Java中对应的关键字就是synchronized。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。

**可见性**

Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。

Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。

除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。

**有序性**

在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：

volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。

# 局部变量
Java线程可以拥有自己的操作数栈，程序计数器、局部变量表等资源；我们都知道，多个线程同时访问共享变量的时候，会导致数据不一致性等并发问题；但是 Java 方法里面的局部变量是不存在并发问题的。

**局部变量的作用域是方法内部的，当方法执行完了，局部变量也就销毁了，也就是说局部变量应该是和方法同生共死的。**

当调用方法时，会创建新的栈帧，并压入调用栈；当方法返回时，对应的栈帧就会被自动弹出。也就是说，栈帧和方法是同生共死的。

**方法的调用就是压栈和出栈的过程，而在Java中的方法的局部变量又是存储在栈帧中，而每个线程都有自己独立的调用栈，所以局部变量不存在并发问题**

![](/assets/images/posts/concurrency/concurrency-7.png)

# 参考资料

http://ifeve.com/java-memory-model-6/

https://blog.csdn.net/hollis_chuang/article/details/80880118

https://my.oschina.net/u/1174461/blog/1916572
