---
layout: post
title: 接口幂等性
date: 2019-11-04
categories:
    - 设计
comments: true
permalink: Idempotence.html
---

# 什么是幂等
在数学里，幂等有两种主要的定义：- 在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。即 `s *s = s`- 某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即`f(f(x)) = f(x)`。

在HTTP/1.1规范中幂等性的定义是：

> A request method is considered “idempotent” if the intended effect on  the server of multiple identical requests with that method is the same  as the effect for a single such request. Of the request methods defined  by this specification, PUT, DELETE, and safe request methods are  idempotent.

HTTP的幂等性指的是一次和多次请求某一个资源应该具有相同的副作用。如通过PUT接口将数据的Status置为1，无论是第一次执行还是多次执行，获取到的结果应该是相同的，即执行完成之后Status =1。

在HTTP规范中定义GET,PUT和DELETE方法应该具有幂等性。(不会对系统产生副作用，不代表每次请求都是相同的结果)

在我们的实际业务上，**幂等性是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。**

# 为什么需要幂等性

- 在App中下订单的时候，点击确认之后，没反应，就又点击了几次。在这种情况下，如果无法保证该接口的幂等性，那么将会出现重复下单问题。
- 在接收消息的时候，消息推送重复。如果处理消息的接口无法保证幂等，那么重复消费消息产生的影响可能会非常大。例如短信重复发送
- 一个订单状态更新接口，调用方连续发送了两个消息，一个是已创建，一个是已付款。但是你先接收到已付款，然后又接收到了已创建


在分布式环境中，网络环境更加复杂，因前端操作抖动、网络故障、消息重复、响应速度慢等原因，对接口的重复调用概率会比集中式环境下更大，尤其是重复消息在分布式环境中很难避免。

假如我们在 5 台机器上部署了支付服务，订单服务调用支付服务因为网络超时触发了重试机制，支付服务就会收到一个支付请求两次，而且因为负载均衡算法落在了不同的机器上。

> 在分布式环境中，网络问题很常见，100次请求，都成功。1万次，可能1次是超时会重试。10万，10次。100万，100次。如果有100个请求重复了，你没处理，导致订单扣款2次，100个订单都扣错了；每天被100个用户投诉；一个月被3000个用户投诉。

为了解决以上问题，就需要保证接口的幂等性，接口的幂等性实际上就是**接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的**。

有些接口可以天然的实现幂等性：

- **查询操作** 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作 
- **删除操作** 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个) 

# 解决方案
## 唯一ID+指纹码

- 唯一ID：业务表的唯一的主键，如订单ID
- 指纹码：为了应对用户在一瞬间的频繁操作，这个指纹码可能是我们的一些规则或者时间戳加别的服务给到的唯一信息码，它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性

将ID + 指纹码拼接好的值作为数据库主键，就可以进行去重了。先去数据库中查询这个id是否存在数据库中。
```
select count(*) from t_check where id = 唯一ID+指纹码
```
如果返回0表示没有操作过，那业务操作后就可以`insert into t_check(唯一ID+指纹码)`。如果返回大于0 表示操作过，就直接返回

缺点：在高并发下存在数据库瓶颈。可以根据ID进行分库分表策略，采用一些路由算法去进行分流。应该保证ID通过这种算法，指纹码多次都落到同一个数据库分片上，这样就由单台数据库幂等变成多库的幂等。

## token机制

每次操作都生成一个唯一 Token 凭证，服务器通过这个唯一凭证保证同样的操作不会被执行两次。这个 Token 除了字面形式上的唯一字符串，也可以是多个标志的组合，甚至可以是时间段标识等等。

1. 数据提交前要向服务的申请token，token放到redis或jvm内存，token要有有效时间
2. 提交后后台验证token，再将 token 标记为已执行（或者删除token）
3. 执行业务逻辑

注意：在redis里如果用select+delete来校验token，存在并发问题，索引建议使用删除操作来判断token，删除成功代表token校验通过。

##  去重表
利用数据库的特性来实现幂等。通常是在表上构建一个唯一索引，那么只要某一个数据构建完毕，后面再次操作也无法成功写入。

这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。

##  状态机控制

通过状态标识的变更，保证业务中每个流程只会在对应的状态下执行，如果标识已经进入下一个状态，这时候来了上一个状态的操作就不允许变更状态，保证了业务的幂等性。

状态标识经常用在业务流程较长，修改数据较多的场景里。最经典的例子就是订单系统，假如一个订单要经历 创建订单 -> 订单支付\取消 -> 账户计算 -> 通知商户 这四个步骤。那么就有可能一笔订单支付完成后去账户里扣除对应的余额，消耗对应的优惠卷。但是由于网络等原因返回了错误信息，这时候就会重试再次去进行账户计算步骤造成数据错误。所以为了保证整个订单流程的幂等性，可以在订单信息中增加一个状态标识，一旦完成了一个步骤就修改对应的状态标识。比如订单支付成功后，就把订单标识为修改为支付成功，现在再次调用订单支付或者取消接口，会先判断订单状态标识，如果是已经支付过或者取消订单，就不会再次支付了。

## 悲观锁 

获取数据的时候加锁获取 
```
select * from table_xxx where id='xxx' for update; 
```
注意：id字段一定是主键或者唯一索引，不然是锁表

悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用 

##  乐观锁
乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：

1. 通过版本号
```
update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version# 
```
2. 通过条件限制
```
update tablexxx set avaiamount=avaiamount-#subAmount# where id=#id# and avaiamount-#subAmount# >= 0 
```

注意：乐观锁的更新操作，最好用主键或者唯一索引来更新，否则更新时会锁表。

## select + insert

并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理。

注意：核心高并发流程不要用这种方法

## 分布式锁 
对于插入数据来说，如果是分布是系统，构建全局唯一索引比较困难。这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁。

这样其实是把多线程并发的锁的思路，引入到多个系统，也就是分布式系统中得解决思路。 

要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供) 

## 对外提供接口的api如何保证幂等 

如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号 

source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求) 

重点对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引

这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。

注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。 

# 参考资料

https://blog.csdn.net/jks456/article/details/71453053