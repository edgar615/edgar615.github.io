---
layout: post
title: RPC健康检查
date: 2020-05-19
categories:
    - rpc
comments: true
permalink: rpc-health-check.html
---

在分布式系统中，为了保证所有服务可用，当服务发生问题时能及时摘除有问题的服务，避免在发请求的时候选择出有问题的节点而影响业务，需要定期检测服务可用性，即健康检查。

一般而言，我们可以通过TCP心跳来检查服务端的运行情况，当服务方下线，调用方肯定会收到连接断开的通知事件。但是TCP心跳是有弊端的，因为长连接的心跳维持都只是表明链路上的正常，服务未必是可用的，比如数据库挂掉。

所以业内一般会用**调用方主动探测**的方式（也可以理解为一种心跳）：调用方通过HTTP或TCP调用服务方发布的某个接口来完成健康检查，返回结果成功表明服务状态确实正常。

服务方的状态一般会有三种情况：

- 健康状态：建立连接成功，并且心跳探活也一直成功；
- 亚健康状态：建立连接成功，但是心跳请求连续失败；
- 死亡状态：建立连接失败;

```
+--------+              +--------+
|        | +------->    |        |
|  健康  |              | 亚健康   |
|        |  <------     |        |
+---+----+              +----+---+
    ^                        |
    |                        |
    |                        |
    |                        |
    |     +--------+         |
    |     |        |         |
    +-----+ 死亡     +<--------+
          |        |
          +--------+

```

节点的状态并不是固定不变的，它会根据心跳或者重连的结果来动态变化，具体状态间转换图如下：

首先，一开始初始化的时候，如果建立连接成功，那就是健康状态，否则就是死亡状态。这里没有亚健康这样的中间态。

紧接着，如果健康状态的节点连续出现几次不能响应心跳请求的情况，那就会被标记为亚健康状态，也就是说，服务调用方会觉得它生病了。

生病之后（亚健康状态），如果连续几次都能正常响应心跳请求，那就可以转回健康状态，证明病好了。如果病一直好不了，那就会被断定为是死亡节点，死亡之后还需要善后，比如关闭连接。

当然，死亡并不是真正死亡，它还有复活的机会。如果某个时间点里，死亡的节点能够重连成功，那它就可以重新被标记为健康状态。


每个service都应该有健康检查API， 比如说 HTTP /health， 来返回这个service的运行状况。这个API端点应该执行一系列的检查。

健康检查的客户端：一个监控服务、服务注册或者负载均衡器，周期性调用api来检查这个service实例的健康状态。


# 参考资料

http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/
