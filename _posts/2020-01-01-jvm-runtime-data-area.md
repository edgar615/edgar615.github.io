---
layout: post
title: JVM运行时数据区域
date: 2020-01-01
categories:
    - jvm
comments: true
permalink: jvm-runtime-data-area.html
---

JDK1.7和1.8的运行时数据区域有所不同

JDK1.7：

![](/assets/images/posts/jvm-runtime-data-area/jvm-runtime-data-area-1.png)

JDK1.8:

![](/assets/images/posts/jvm-runtime-data-area/jvm-runtime-data-area-2.png)

其中线程私有的是：

- 程序计数器
- 虚拟机栈
- 本地方法栈

线程共享的是：

- 堆
- 方法区
- 直接内存(非运行时数据区的一部分)

# 程序计数器

程序计数器是一块较小的内存空间，可以看作是**当前线程**所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

在多线程中，就会存在线程上下文切换，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

```
public int test() {
    int x = 0;
    int y = 1;
    return x + y;
}
```

java 文件被翻译为字节码的时候，字节码大概类似于下面的样子

```
  public int test();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: iconst_0
         1: istore_1
         2: iconst_1
         3: istore_2
         4: iload_1
         5: iload_2
         6: iadd
         7: ireturn
      LineNumberTable:
        line 6: 0
        line 7: 2
        line 8: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       8     0  this   Lcom/taobao/resttest/Append;
            2       6     1     x   I
            4       4     2     y   I

```
上面左边的 0、1、2、3 ，就是类似于字节码的行号（实际是指令的偏移地址），程序计数器中保存中的值，就是它们；字节码解释器，就是根据它们，来执行程序的 ；

从上面的介绍中我们知道程序计数器主要有两个作用：

    字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
    在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

如果线程执行 Java 方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行 Navtive 方法，程序计数器值则为空（Undefined）。因为 Navtive 方法是 Java 通过 JNI 直接调用本地 C/C++ 库，可以认为是 Native 方法相当于 C/C++ 暴露给 Java 的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。由于该方法是通过 C/C++ 而不是 Java 进行实现。那么自然无法产生相应的字节码，并且 C/C++ 执行时的内存分配是由自己语言决定的，而不是由 JVM 决定的。

由于是线程私有的，程序计数器的生命周期随着线程，线程启动而产生，线程结束而消亡。

程序计数器保存的是当前执行的字节码的偏移地址，当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址；因此，永远都不可能内存溢出的；因此在jvm虚拟机规范中，程序计数器是唯一一个没有规定 OutOfMemoryError 异常 的区域。

# Java 虚拟机栈

与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。

所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。

Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

![](/assets/images/posts/jvm-runtime-data-area/jvm-runtime-data-area-4.png)

## 栈帧
栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接 （Dynamic Linking）、方法返回值和异常分派（Dispatch Exception）。

局部变量表和操作数栈的大小要视对应的方法而定，他们是按字长计算的。但调用一个方法时，它从类型信息中得到此方法局部变量区和操作数栈大小，并据此分配栈内存，然后压入Java栈 

**局部变量表**

局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。

堆上包含在Java程序中创建的所有对象。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。

下面这张图演示了调用栈和本地变量存放在线程栈上，对象存放在堆上。

![](/assets/images/posts/jvm-runtime-data-area/jvm-runtime-data-area-3.png)

需要注意的是，局部变量表所需要的内存空间在编译期完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小。

局部变量表被组织为以一个字长为单位、从0开始计数的数组，类型为short、byte和char的值在存入数组前要被转换成int值，而long和double在数组中占据连续的两项，在访问局部变量中的long或double时，只需取出连续两项的第一项的索引值即可,如某个long值在局部变量区中占据的索引时3、4项，取值时，指令只需取索引为3的long值即可。

```java
public static int runClassMethod(int i,long l,float f,double d,Object o,byte b) { 
   return 0;   
}

public int runInstanceMethod(char c,double d,short s,boolean b) { 
       return 0;   
}
```

![](/assets/images/posts/jvm-runtime-data-area/stack3.png)

**操作数栈**

栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。

和局部变量表一样，操作数栈也被组织成一个以字长为单位的数组。但和前者不同的是，它不是通过索引来访问的，而是通过**入栈和出栈**来访问的。可把操作数栈理解为存储计算时，临时数据的存储区域。下面我们通过一段简短的程序片段外加一幅图片来了解下操作数栈的作用。

```java
int a = 100;
int b = 98;
int c = a+b;
```

![](/assets/images/posts/jvm-runtime-data-area/stack4.png)

从图中可以得出：操作数栈其实就是个临时数据存储区域，它是通过入栈和出栈来进行操作的。

**指向运行时常量池的引用**

因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量

**方法返回地址**

当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。由于每个线程正在执行的方法可能不同，**Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。**

当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。

Java方法有两种返回方式：

- return 语句。
- 抛出异常。

不管哪种返回方式都会导致栈帧被弹出。

**栈的整个结构**
在前面就描述过：栈是由栈帧组成，每当线程调用一个java方法时，JVM就会在该线程对应的栈中压入一个帧，而帧是由局部变量区、操作数栈和帧数据区组成。那在一个代码块中，栈到底是什么形式呢？下面是我从《深入JVM》中摘抄的一个例子:

```java
public class Main{    
	public static void addAndPrint(){      
    	double result = addTwoTypes(1,88.88);    
        System.out.println(result);    
    }   
         
    public static double addTwoTypes(int i,double d){  
    	return i + d;  
    }
}
```

![](/assets/images/posts/jvm-runtime-data-area/stack5.png)

上面所给的图，只想说明两件事情：

1. 只有在调用一个方法时，才为当前栈分配一个帧，然后将该帧压入栈
2. 帧中存储了对应方法的局部数据，方法执行完，对应的帧则从栈中弹出，并把返回结果存储在**调用 方法的帧的操作数栈中**

Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。

- **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

# 本地方法栈

本地方法栈和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

# 堆

对于大多数应用来说，堆是java虚拟机管理内存最大的一块内存区域，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。**

> java虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。
>
> 即时编译器:可以把把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序)
>
> 逃逸分析:通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。

堆可以处于物理上不连续的空间，只要逻辑上是连续的即可。

Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.由于现在收集器基本都采用分代垃圾收集算法，所以Java堆被分为了三个部分：

- 年轻代 ： 常常又被划分为Eden区和Survivor（又分为From Survivor和To Survivor两部分）区，默认空间分配比例是8：1：1
- 老年代
- 永久代 

  - 在Java **6**中，永久代在**非堆**内存中
  - 在Java **7**中，永久代的**静态变量**和**运行时常量池**被**合并到堆**中
  - 在Java **8**中，永久代被**元空间**取代

JDK1.7

![](/assets/images/posts/jvm-runtime-data-area/jvm-runtime-data-area-5.png)

JDK1.8

![](/assets/images/posts/jvm-runtime-data-area/jvm-runtime-data-area-6.png)

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数`-XX:MaxTenuringThreshold`来设置。

虚拟机提供了一个`-XX:PretenureSizeThreshold`参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制

注意　PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel
Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。

**参数**

- `-XX:InitialSurvivorRatio` 新生代Eden/Survivor空间的初始比例，默认8
- `-XX:NewRatio` Old区/Young区的内存比例，默认2
- `-XX:MaxTenuringThreshold` 一个对象从新生代晋升到老年代的阈值。默认值是**15**

# 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与 Java 堆区分开来。

方法区主要用来存放已被虚拟机加载的类相关信息。Class文件中除了有类的版本、字段、方法、接口、父类等描述信息外,还有一项信息是常量池( Constant pool table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入运行时常量池中存放。**运行时常量池相对于class文件常量池的另外一个特性是具备动态性，java语言并不要求常量一定只有编译器才产生，也就是并非预置入class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。**

JVM在执行某个类的时候，必须经过加载、连接（验证、准备、解析）、初始化

- 加载类时，JVM会先加载class文件，在class文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池
	- 常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用
	- 字面量：字符串（String a="b"），基本类型的常量（final修饰）
	- 符号引用：类和方法的全限定名、字段的名称和描述符、方法的名称和描述符
- 当类加载到内存中后，JVM会将class文件常量池中的内容存放到运行时常量池中
- 在解析阶段，JVM会把符号引用替换为直接引用（对象的索引值）

运行时常量池是全局共享的，多个类共用一个运行时常量池，class文件中的常量池多个相同的字符串在运行时常量池只会存在一份

**方法区 != 永久代**

《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。**方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。**也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

JDK 1.8 之前通常通过下面这些参数来调节方法区大小

- `-XX:PermSize=N` 方法区(永久代)初始大小
- `-XX:MaxPermSize=N` 方法区(永久代)最大大小,超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

JDK 1.8 彻底移除了永久代，取而代之是元空间，元空间使用的是直接内存。

- `-XX:MetaspaceSize=N` 设置Metaspace的初始（和最小大小）
- `-XX:MaxMetaspaceSize=N` 设置Metaspace的最大大小，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。
- `-XX:MinMetaspaceFreeRatio` 在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
- `-XX:MaxMetaspaceFreeRatio` 在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集

与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

永久代或元空间内并没有保存类实例的具体信息（及类对象），也没有反射对象（例如方法对象），这些内容都保持在常规的堆空间内，永久代和元空间保持的信息只对编译器或者JVM的运行时有用，这部分信息也称为“类的元数据”。

**为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?**

整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。你可以使用`-XX：MaxMetaspaceSize`标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize`调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

# 运行时常量池
运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

JDK1.8的运行时常量池位于元空间

![](/assets/images/posts/jvm-runtime-data-area/jvm-runtime-data-area-7.png)

# 字符串常量池

字符串常量池独立于运行时常量池，它实际是一种由C++实现的Map，结构上类似于Hashtable，区别在于其无法自动扩容。

>  String的String Pool是一个固定大小的`Hashtable`，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用`String.intern`时性能会大幅下降（因为要一个一个找）。

在 jdk6中`StringTable`是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，`StringTable`的长度可以通过一个参数指定：`-XX:StringTableSize=99991`

字符串常量池是全局的，JVM 中独此一份，因此也称为全局字符串常量池。运行时常量池中的字符串字面量若是成员的，则在类的加载初始化阶段就使用到了字符串常量池；若是本地的，则在使用到的时候（执行此代码时）才会使用到字符串常量池。其实，“使用常量池”对应的字节码是一个 ldc 指令，在给 String 类型的引用赋值的时候会先执行这个指令，看常量池中是否存在这个字符串对象的引用，若有就直接返回这个引用，若没有，就在堆里创建这个字符串对象并在字符串常量池中记录下这个引用（jdk1.7)。String 类的 intern() 方法还可在运行期间把字符串放到字符串常量池中。JVM 中除了字符串常量池，8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲（Character是[0,127]，Integer可以通过`-XX:AutoBoxCacheMax=<size>`修改），超出此范围仍然会去创建新的对象。其中：

- 在JDK1.6及更早版本中字符串常量池位于方法区
- 在JDK1.7及以后的版本中中字符串常量池位于堆


# 直接内存
直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是JVM规范中定义的内存区域。但这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。

JDK1.4中新引入了NIO机制，它是一种基于通道与缓冲区的新I/O方式，可以直接从操作系统中分配直接内存，即直接堆外分配内存，这样能在一些场景中提高性能，因为避免了在Java堆和Native堆中来回复制数据。

# 内存溢出
**内存泄露（Memory Leak）**：程序在申请内存后，对象没有被GC所回收，它始终占用内存，内存泄漏的堆积最终会造成内存溢出。

**内存溢出（Memory Overflow）**：程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于老年代或永久代垃圾回收后，仍然无内存空间容纳新的Java对象的情况。通常都是由于内存泄露导致堆栈内存不断增大，从而引发内存溢出。

运行时区域大概了解后，我们在来总结一下：

| 运行时区域           | 异常                                 | 主要原因                                                     |
| -------------------- | ------------------------------------ | ------------------------------------------------------------ |
| 虚拟机栈和本地方法栈 | StackOverflowError、OutOfMemoryError | StackOverflowError：线程请求的栈深度大于虚拟机所允许的最大深度；OutOfMemoryError：虚拟机在扩展栈时无法申请足够的内存空间 |
| 程序计数器           | 无                                   | 无                                                           |
| 堆                   | OutOfMemoryError                     | 对象数量到达最大堆的容量，内存泄漏、内存溢出                 |
| 方法区和运行时常量池 | OutOfMemoryError                     | 反射，动态代理：CGLib、JSP、OSGI等                           |



# 参考资料

https://juejin.im/post/5d4e2aa7f265da03d15540b9

http://zhongmingmao.me/2019/09/07/java-performance-jvm-memory-model/

https://www.kancloud.cn/imnotdown1019/java_core_full/1012266#23__81
