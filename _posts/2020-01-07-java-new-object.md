---
layout: post
title: java对象的创建过程
date: 2020-01-07
categories:
    - jvm
comments: true
permalink: java-new-object.html
---

Java在new一个对象的时候，会经过下列几步

![](/assets/images/posts/new-object/new-object-1.png)

# 1.类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

在[classloader](https://edgar615.github.io/classloader.html)的文章中已经描述了类加载过程：加载>验证>准备>解析>初始化（先父后子）

# 2.分配内存
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

## 分配方式
分配方式有**“指针碰撞”和“空闲列表”**两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

**指针碰撞**

假设JAVA堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就是把这个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式就称之为指针碰撞。

**空闲列表**

如果JAVA堆中的内存并不是规整的，使用的内存和未使用的内存相互交错，这样的话就没有办法进行简单的指针碰撞了，虚拟机就必须维护一个列表，列表上记录着，哪些内存是可用的，哪些内存是不可用的。在分配的时候，从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式就称之为空闲列表。

而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"，值得注意的是，复制算法内存也是规整的，因此serial和parNew垃圾收集器的内存是规整的，而CMS不是规整的

## 线程安全
在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：**CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
-  **TLAB：**为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。虚拟机是否使用TLAB，可以通过`-XX：+UseTLAB`参数来设定。

# 3. 初始化零值
内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

如果使用TLAB，这一工作也可以提前至TLAB分配时进行

# 4. 设置对象头
初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。**这些信息存放在对象头中。**另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

# 5.执行 init 方法
在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

一般来讲，`new`指令后面都会跟着`invokespecial`来执行`<init>`方法，也就是执行类构造器里的逻辑.

```
0: new           #2                  // class com/taobao/resttest/User
3: dup
4: invokespecial #3                  // Method com/taobao/resttest/User."<init>":()V
```

如果有类似于`Child c = new Child()`形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它

需要注意的是，每个子类对象持有父类对象的引用，可在内部通过super关键字来调用父类对象，但在外部不可访问

通过实例引用调用实例方法的时候，先从方法区中对象的实际类型信息找，找不到的话再去父类类型信息中找。

如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为虚方法表的方法来优化调用的效率。

所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。


# 参考资料

https://mp.weixin.qq.com/s/kRVQGz2ZWnRShiFVePwiRw

https://www.kancloud.cn/imnotdown1019/java_core_full/1012266#_HotSpot__155